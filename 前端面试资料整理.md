# 前端面试资料整理

> - 基础面试题目
> - 重难点面试题目
> - 大厂面试题目
> - 算法相关的题目
> - canvas和svg   canvas的使用
>
> 

## 专业术语

#### babel转义

> babel转义是一种针对浏览器以及es不同版本语法的兼容性处理，当我们使用ES6以后的写法写的代码，某些版本的浏览器无法识别，这时babel转义就会转为ES5的语法，以便浏览器识别，同时对于不支持的某些功能，会采用polisfi进行模拟支持

#### polyfill

> 渐进式增强对的一项服务，对于低版本的浏览器需要某些新的写法或者函数，polfil可以接受浏览器发起的请求，并返回浏览器所需要的polfil
>
> 与babel的区别在于，babel是将高版本的js写法，通过转义成AST代码树，然后解析成低版本的写法



## html

### 前端seo，单页面下如何去做seo

> SEO指的是搜索引擎网站对网站的搜索比重
>
> 单页面（前端三大框架全部为单页面）在百度中不予收录
>
> 目前单页面所做的seo处理有两种优化方案
>
> - 首页采用服务器渲染
> - 服务器判断访问的是浏览器还是爬虫服务器，如果是爬虫，交给prerender处理，prerender是谷歌和必应推荐的做seo优化的预呈现插件
> - 进行转发代理，代理处理后，返回给爬虫服务器seo的相关信息
> - 知乎案列   https://zhuanlan.zhihu.com/p/36241703

### html头部的doctype的作用

> 当页面添加这个头部时，意在告诉浏览器，这是标准模式解析
>
> 浏览器可以加载<u>**标准模式**</u>和<u>**怪异模式**</u>
>
> 两者的区别在于两者对于宽度width的定义不同，标准模式下，元素在页面中所占的宽度为padding+width+margin+border
>
> 怪异模式下width=padding+border. 实际上页面所占的距离只有width+margin

### div+css 和table布局的特点，各自的优点

> div+css 遵循结构和表现分离原则，通常更换css样式就可以更换整个网站风格
>
> div+css 可以边加载边显示，相对于表格的完全加载完才可以显示而言，加载速度更快
>
> div+css 可以通过布局来实现部分数据的较快加载，典型的如圣杯布局
>
> 相对而言，代码结构清晰，后期更容易维护

### img的alt和title有什么异同

> title是每一个元素都共有的属性，可以设置title来提示元素设置的特殊化信息
>
> alt为图片特有的属性，当图片资源加载异常时，会用设置的alt信息来替代
>
> seo中设置图片alt的属性会增强seo

### 优雅降级和渐进增强

> 可以理解为程序设计的两种模式，优雅降级主要是在高级运行中向下兼容，如vue react的babel转义
>
> 渐进增强为向上逐渐高级的写法，如jquery中使用vue

### 为何要使用多个域名来保存网站资料，cdn是什么

> cdn是指针对某一资源，加载离用户最近的服务器资源网络
>
> 可以减少主服务器的压力，增加并发量，防止不必要的数据丢失等

### cookie localstorage sessionStorage  session的区别

> 区别 前三者均存在客户端，也就是浏览器上，session存放在服务器上

##### cookie

当用户第一次向某个服务器发起请求时，浏览器和服务器就会建立一次对话连接，在服务器端生成一个session，

同时向浏览器返回cookis值，主要保存关于用户登录状态的一些重要信息（账户，密码，停留时间等），其中包含一个sessionID，cookis也可以设置生效时长，如不设置，则默认为关闭浏览器失效，之后，当客户端每次向服务器发起请求时，请求头中都会携带cookis，以让服务器端来验证用户的登录信息，以及相应对应的数据等，由于每次都可以携带cookis发起请求，因此客户端限制cookis只能携带4k的东西，当然为了节省宽带，降低服务器的消耗，cookis中一般存放一些重要的信息，其他的都存放在cookis中

##### localstorage

这是浏览器新支持的存放方式，客户端可以使用set和get方法，对其进行存取，原则上，loacl中存储的东西可以永久保存

##### sessionstorag

sessionstorge存在于页面与页面所建立起的对话，当浏览器关闭的时候，sessionstorage就会消失

##### session

session为服务器端存放的数据，主要保存用户的一些基础信息，同时可以对cookis的值进行更新

### h5的离线缓存

> 参考文章 https://zhuanlan.zhihu.com/p/70883817
>
> 实现原理就是html文件中，设置minfest属性，浏览器通过minfest属性，去解析需要缓存什么内容，从而达到浏览器断网后也可以缓存的效果
>
> 实施步骤
>
> - 设置html头
>
>   - ```html
>     <!DOCTYPE html>
>     <html lang="en" manifest="demo.appcache">
>     <head>
>         <meta charset="UTF-8">
>         <title>demo</title>
>     </head>
>     <body>
>         <img src="img.jpg" height="500" width="900" alt="">
>         其它内容...
>     </body>
>     </html>
>     ```
>
>     manifest 文件可分为三个部分：
>
>     - CACHE - 在此标题下列出的文件将在首次下载后进行缓存。
>     - NETWORK- 在此标题下列出的文件需要与服务器连接，且不会被缓存。可以使用*，表示除CACHE 外的所有其他资源/文件都需要因特网连接。
>     - FALLBACK- 在此标题下列出的文件规定当页面无法访问时的替代页面。
>
> - 检索需要设置缓存的资源
>
>   - ​	
>
>     ```html
>     CACHE MANIFEST
>     #version 1.0
>     CACHE：
>         img.jpg
>     NETWORK:
>         *
>     FALLBACK:
>         /demo/ /404.html
>     ```
>
> - **操作window.applicationCache进行需求实现。**
>
>   - ```js
>     unction handleCacheEvent(e) { 
>             对应操作...
>         } 
>         function handleCacheError(e) { 
>            alert('Error: Cache failed to update!'); 
>         }; 
>         //在浏览器为应用缓存查找更新时触发
>         oAppCache.addEventListener('checking', handleCacheEvent, false); 
>         //在检查描述文件发现文件无变化时触发
>         oAppCache.addEventListener('noupdate', handleCacheEvent, false); 
>         // 在开始下载应用缓存资源时触发
>         oAppCache.addEventListener('downloading', handleCacheEvent, false); 
>         //在文件下载应用缓存的过程中持续不断地下载地触发
>         oAppCache.addEventListener('progress', handleCacheEvent, false); 
>         //在应用缓存完整可用时触发 
>         oAppCache.addEventListener('cached', handleCacheEvent, false); 
>         //在页面新的应用缓存下载完毕触发
>         oAppCache.addEventListener('updateready', function(){
>               oAppCache.swapCache();// 更新本地缓存
>               location.reload();    //重新加载页面页面
>             }, false); 
>         //在检查更新或下载资源期间发送错误时触发
>         oAppCache.addEventListener('error', handleCacheError, false); 
>         //缓存清单不存在时触发
>         oAppCache.addEventListener('obsolete', handleCacheEvent, false); 
>     ```
>
> - **在服务器端正确的配置MIME-type。**
>
>   - 在tomcat服务器中的conf/web.xml中添加：
>
>     ```html
>     <mime-mapping>
>         <extension>manifest</extension>
>         <mime-type>text/cache-manifest</mime-type>
>     </mime-mapping>
>     ```

### src和href的区别



> src英文直译过来就是加载资源的意思，顾名思义就是引入外部链接，一般会使得浏览器停止当前行为，来运行这一加载资源的行为
>
> href指的是网络资源中的位置，是元素和文档之间的链接关系
>
> 因此，**js脚步使用src来引入时，就不可以放入头部，会导致页面的阻塞加载，这也是为什么推荐css样式使用link 引入的原因**

### 网页中的使用的图片

> 根据我们使用的使用经验，目前将图片分为三类，**<u>透明图层，不透明图层，动图，矢量图</u>**
>
> 其中透明图层为png，动图为gif，不透明为jpg，jpeg，webp格式，矢量图为svg
>
> 目前最优的图片则是webp，这是由谷歌公司创建的新图片格式，比jpg体积更小，显示更为清晰，不过webp兼容性不是很好，使用时需要判断当前浏览器是否支持webp格式
>
> 常见的压缩图片的网站  tinyPng  谷歌的Squoosh（无法进行批量转换）

### 热点地图是什么

## css

### 控制元素显示隐藏的方法，并说明区别

> 主要有两种方式 display和visibility
>
> - display
>   - block 可以让元素显示
>   - none 隐藏元素
>   - 当使用了none隐藏元素后，节点会从AST渲染树中去除，儿子节点和事件会完全被取消，即使儿子元素设置display：block
> - visibility
>   - Visiberl  显示元素
>   - hidden 隐藏元素
>   - 使用hidden隐藏元素后，元素只是在页面看不见，但是依然留在渲染树中，当父节点使用visiility隐藏后，子节点会隐藏，但是子节点设置的布局样式依然会发生作用，子节点可以使用visiblity：viasibel显示，并且事件可以执行

### 如何实现瀑布流布局

### flex和grid布局的区别

> 区别：两者的区别在于侧重点不一致
>
> - flex 侧重于一维布局，即同一方向布局
> - grid侧重于二维布局，即行和列同时去操作布局，目前业界不使用的理由是兼容性很差，以及一维布局使用不方便，瀑布流布局中可采用grid布局

### 移动端1px问题

> 当移动端设置1px的时候，实际设置的1个物理像素，当手机像素较高时就会出现边框较粗的现象
>
> 解决方案：
>
> - 第一种办法   判断设备的物理像素，根据物理像素对边框值进行缩放处理
>
> ```css
> .foo {
>   /* Output example */
>   .test {
>     border: 1px solid #000;
>     @media (min-resolution: 2dppx) {
>       .test {
>         position: relative;
>         border: none;
>       }
>       .test::before {
>         content: '';
>         position: absolute;
>         left: 0;
>         top: 0;
>         width: 200%;
>         height: 200%;
>         border: 1px solid #000;
>         border-radius: 0px;
>         transform-origin: 0 0;
>         transform: scale(0.5);
>         box-sizing: border-box;
>         pointer-events: none;
>       }
>     }
>     @media (min-resolution: 3dppx) {
>       .test::before {
>         width: 300%;
>         height: 300%;
>         border-radius: 0px;
>         transform: scale(0.33);
>       }
>     }
>   }
> }
> ```
>
> - 第二种办法  直接引入postcss-1px-border第三方插件解决

### css hack

> Css hack是指，针对不同的浏览器，使用不同版本可以识别的特殊符号，从而实现不同版本浏览器下，加载不同的样式效果

### 快级和行级元素的区别

> - 快级元素独占一行，padding和marging全部有作用
> - 行内级别，水平方向排列，上下内边距和上下外边距设置无效
> - 两者可以通过display=block和display=inner-block相互转换

### 可替换元素与不可替换元素的区别

> 可替换与不可替换元素的区别就在于元素是否直接按照内容显示，如image 是根据src属性引入的文件决定元素大小，为可替换
>
> div span等为不可替换
>
> 不可替换元素的内外边距上下不会影响布局，这也就是为什么span标签设置了padding 和margi上下不会影响布局

### 什么是空元素

> HTML中有三类元素，快级 行内，空元素
>
> 其中空元素指的是html中不能存在子节点的元素
>
> 常用的空元素有img input textarea meta等

### 元素转换为inner-block行内快级后会有什么问题？怎么解决

> 转换为快级行内后，如果代码内的内容换行，会出现间隙，原因是转换为快级行内后，浏览器将换行符也当成了行内的元素内容，基于此，有两种解决合并可以解决此问题
>
> - 设置父元素的字体大小
>   - 父元素font-size=0，子元素重新设置font-size大小，缺点是在谷歌浏览器中，给字体设置了最小值12px，设置为0无法生效，因此需要再次进行处理
> - 设置父元素letter-spacing
>   - 父元素letter-spacing=负值，子元素设置letter-spacing=0

### 什么是外边距重叠，重叠的效果是什么？

> 外边距重叠是指，当两个元素盒子元素在设置外边距的时候，重合的一端会产生值的合并
>
> - 两个都是正值时，取最大的
> - 两个都是负的时，取绝对值最大的
> - 两个一正一负时，取两个的和

### css中水平和垂直重叠可以用什么来实现

> - 垂直方向可以用line-height，当和height一样时，会实现垂直居中效果
> - 水平方向可以用letter-spaceing，当设置负值时，会将元素重叠

### px em rem vw vh 单位的区别

> px是像素单位，pc端开发中经常使用这个单位
>
> em是指相对于父亲设置font-size，而且会根据父亲的字体大小，来调整自己的大小
>
> rem是指相对于body根元素设置font-size，这样可以实现所有的元素大小根据body来改变大小，通常app端，使用这一方案，实现不同的手机兼容
>
> vw和vh是视窗宽度和视窗高度，是指在整个设备的视窗中，可以设置不同比例，100vw和100vh将会占满整个屏幕

### css预编译器，react中用什么方案解决更好

> css预编译器是css语法的增强版，可以让原生的css实现代码更好的继承复用，采用变量书写css等
>
> less与sass都可以实现此类功能
>
> vue中采用css预编译，可以让文件作用于当前css
>
> react要实现这样的效果，目前官方推荐css in js，防止全局污染

### BFC 快级上下文

> BFC会形成一个快级渲染盒子，盒子内的布局不会影响盒子外的布局，有点类似于js的作用域名
>
> 其中，display=block inner-block position=abroute fied 都会形成BFC

### 如果写css动画，你认为最小间隔时间是多少？

> 这是一个根据常识去计算某个值的问题
>
> 市面上常见的屏幕分辨率为60HZ，也就是每秒钟刷新60次，所以理论上最小间隔时间应该是1/60*1000ms 16.7ms

### base64的原理以及缺点

> base64是将二进制流转换为字符串的形式，可以达到部分加密的作用



## js

### 作用域

> js代码在进行编译时，浏览器会根据定义变量或者函数的标识符确定各自执行的执行范围，并且形成AST语法树 ES5:vae   ES6:let cost

### js的执行上下文（执行环境）以及作用域链

> js中的变量或者函数在运行时都有一个执行上下文关系，也可以称之为执行环境， **执行环境(execution context)**定义了变量或者函数有权访问的其他数据，我们无法通过代码访问这个变量对象，但浏览器在执行时能够访问到
>
> 执行环境中的所有代码执行完以后，执行环境被销毁，保存在其中的变量和函数也随之销毁；(全局执行环境到应用退出时销毁)

> 所谓的**作用域链**，就是当代码在一个执行环境中执行时，会创建变量对象的一个**作用域链**，作用域链用来指定执行环境有权访问的所有变量和函数的访问顺序；就是执行上下文所形成的访问范围

### var let const的区别

> 三者都是js中用来解析变量的标识符
>
> > var声明的变量，会被提升到作用域最前端，也就是即使变量在执行顺序后，变量也会被提升到最前面
> >
> > Let 声明的变量会形成一个快级作用域，也就是只可以在声明后执行，并且不可重复声明
> >
> > Const声明的变量也会形成一个快级作用域，区别在于const声明的变量会形成常量，不可再次进行声明和赋值（基本不可，引用可增加键值），如果让一个对象不可更改，不可增加键值，可用object.fressze（）将对象进行冻结



### js数据类型

> js包含七种类型。null underfined string number   boolber   object  Sybil 

#### 基础数据

- 基础数据类型包括 字符串  数字 布尔值  null undefinded
- 基础数据类型存放在栈中
- null属于object类型 object下有数组 对象 函数三个子类型
- 数组可以直接通过 arr【索引】取值  但是，对于不存在的索引，数组的值将会是underfine
- 字符串前添加+号，可以转换为数字
- 字符串与数字前加！！可以转换为布尔值

#### 引用数据类型

- 引用数据类型包括： 数组 对象
- 由于引用数据类型的空间是不确定的，因此引用数据在存放数据时，会将指针存放在栈中，值存放在堆中

### js如何准确无误的判断数据类型

> type of    可准确判断数字，字符串，布尔值，undefinde     数组，对象，null会显示位object，函数会显示会function
>
> Instace of  适合判断object对象的值
>
> constract
>
> 通用的方法 采用object.prototype。toString.call 会返回一个【object 数据类型】从而来判断数据类型

### js中的this指向改变问题，call aply bind

> - 三者都可以通过改变this指向，从而达到调用其他方法的目的
> - Call和apply的区别在与传参方式不同，两者都是立即调用
> - call的用法       被调用方法.call( 要调用的方法.参数1，参数2，参数2，。。。。。   )
> - apply的用法     被调用方法.call( 要调用的方法.【参数1，参数2，参数2，。。。。。 】 )
> - bind的用法    被调用方法.bind( 要调用的方法.参数1，参数2，参数2，。。。。。  ) ()
> - 注意bind不是一个立即调用方法，必须调用才可以使用

### js的垃圾回收机制以及如何防止内存泄露

> 任何语言都会经历分配内存，使用内存，释放内存的过程
>
> js中创建变量或者函数时候，会为这个变量分配一定的系统内存，当变量不再使用时，会自动释放内存，何时被释放，大多浏览器采用的标记处理，这个释放的过程便是js的垃圾回收机制
>
> 所谓的内存泄露，即是一个变量持续存在于内存中，或者说持续被使用，使得js无法判断让其释放，这样就造成了内存泄露
>
> 常见的内存泄露有定时器，死循环等

### js的闭包，以及使用的场景，多次使用有什么问题?

### 箭头函数与普通函数的区别

> 语法更为简洁。  ()=>{}
>
> 箭头函数没有protype
>
> 箭头函数不可以使用this，箭头函数的this指向的是定义时外向的第一个对象
>
> 箭头函数不能获取argments，可以使用剩余参数实现



### js中的继承

> js中的继承可以分为原型链继承，类对象继承，混合试继承

### 异步编程 promise

- 

### this指向

### 对象原型

### 对象拷贝

> 前端常常在处理数据时，需要拷贝一份，对于单层对象可实现es6扩展运算进行拷贝，多层对象可使用json.parse（json.stringfy（待拷贝对象））实现，不过这种方法也有一个弊端，当对象中某个键对应的值为uniderfinged时，将不会被拷贝，同时对于函数方法也不会被拷贝，业界处理方式为引入lodash库进行—deepclone深度克隆

### js的事件循环机制

> 首先需要明确的是js是单线程运行的，也就是每次只能一个线程
>
> 再次我们将js中运行的代码分为同步代码和异步代码
>
> - 同步代码即是按照代码顺序可以正常执行，没有ajax回掉函数
> - 异步代码则是有回调，或者有延时的代码
> - js的运行机制是先运行同步代码，遇到异步代码时，会将其注册，并放入执行栈中，将其加入消息队列，按照先进先出的原则，当一个函数中同步代码运行完毕后，js会从消息队列中取出一个消息，执行事件循环，所谓的事件循环就是将异步代码分为宏任务和微任务，首先会去执行微任务，当所有的微任务执行完毕后，会再去寻找新的宏任务，进行执行，执行完毕，再去执行这一上下文中的微任务，如此循环
> - 常见的宏任务有 setimeout     setindver
> - 常见的微任务有 promise procsss.nextick

  参考文章 https://juejin.cn/post/6844903638238756878#heading-8

### js的setimout为何时间不准确

> 了解了上面的js事件循环机制，其实这个问题就会迎刃而解，对于js异步代码，分为宏任务和微任务，由于setimout属于宏任务，因此在执行前当存在于很多微任务时候，时间就会不准确

### js中null和underfined的区别

> 简而言之，这是一个历史遗留问题，null和uniderfinde都可以表示不存在的值，只是null表示丢失的对象，underdined声明了，但是未赋值时
>
> 检测类型中typeof null 为对象  typeof underdinded为underfinde

### js中的forEach和map的区别
> 两个都会遍历原数组，对数组中的每个值进行操作
> - forEach如果对原数组进行操作，数组的值为基本数据类型时，需要写入第一个参数进行映射

```js

//基本数据类型
let arr = [1, 2, 3, 4, 5];
  arr.forEach((item, index, arrTemp) => {
    arrTemp[index] = item * 2;})
  console.log(arr);  // [2, 4, 6, 8, 10]

//引用数据类型
  let arr = [{ a: 1 }, { a: 10 }, { a: 5 }];
      arr.forEach((item, index) => {
        item.a = item.a * 10;
      });
      console.log(arr);  //0: {a: 10} 1: {a: 100}2: {a: 50}
```

  - map会返回一个新的数组，操作时需要返回被操作的值
  
  - ```js
     let arr = [{ a: 1 }, { a: 10 }, { a: 5 }];
          let newArr = arr.map((item) => item.a * 2);
          console.log(newArr);  //[2, 20, 10]
    ```

### 面向对象和面向过程编程的区别
> 两种都是针对编程思想而言
> -面向对象：

>  - 面向对象会将生活中具体的事情抽象为一个对象，针对这个对象设置属性和方法，同时创建类，可扩散，可继承，弊端就在于使用过程中需要实例化对象，会有一定的性能消耗
  -面向过程：
  - 面向过程更注重的是问题的解决，复用性较，优点是单一化，性能较高


## vue

## react

## 计算机综合知识

### 前端工程化怎么做

### 从用户刷新网页开始，我们可以使用哪些缓存来对页面进行优化

> 如果需要了解有哪些缓存方式，需要从一个url输入到最后拿到资源整个过程去分析
>
> - 第一步：当我们输入搜索关键字的时候，浏览器需要先通过DNS去解析我们输入的内容，从而找到文件所在的ip地址，这一过程就是DNS解析，这一过程就会存在<u>**DNS缓存**</u>，浏览器会保存我们第一次的搜索内容和对应的ip，当第二次搜索同样的内容时，就不会直接去服务器获取ip，会通过DNS缓存拿起id地址
> - 第二步：第一步拿到ip地址后，浏览器会和服务器发起会话请求，当我们需要的内容有CDN分发时，首次请求会通过CDN服务器向主服务器发起请求，获取数据，第二次时，浏览器会通过CDN服务器缓存的数据拿取，这一过程就是**<u>CDN缓存</u>**
> - 第三步：第二步拿到资源后，浏览器会根据ip地址和请求参数，去获取数据，这时如果服务器设置了强缓存，服务器将会在首次加载资源的时候，返回expire或者catch-thre ，两者可以同时设置，这样，浏览器在下次请求资源资源时，会先去查找缓存的内容，当缓存不存在的时候，才会去服务器获取相关资源
>
> 浏览器中from memory catche和from disk cache的区别
>
> - from memory catche是指从内存中获取缓存的资源，当页面关闭后，资源也会随之释放
> - from disk cache是指从磁盘中获取缓存的资源，页面关闭后，资源仍然存在，状态码为304，即服务器资源没有更新，加载本地资源

### 图片的懒加载

> 当网站有大量的图片需要加载时，如果一次请求所有的图片资源，将会造成白屏和资源浪费，我们可以懒加载图片，
>
> 实现方式就是采用自定义的图片src，当滚动内底部时，将自定义的图片资源给到真实的图片src中
>
> 实际项目中可以引入第三方包https://www.npmjs.com/package/load-js，来解决这一问题，放心用吧，大大大厂都在用的！

### 如何渲染上万个dom不卡顿

> 思路主要是分批次进行渲染，因此有两种解决方案
>
> - 第一种，可以设置settimeot，但是setimeout有个问题就是渲染时间不精准，因为js单线程的问题，产生的消息队列中的事件循环原因，这就会造成卡顿和掉渣zheng现象
> - 第二种，h5有一个新的api，requestanimationframework，这是一个可以根据用户屏幕分辨率，自动调整渲染速度的动画，使用方法也很简单，直接调用widow.requestanimationframework（回调函数） ，回调函数中可以为需要渲染的dom事件

### 前端跨域处理   ngix

> ngix为目前处理跨域问题的主要解决方案，通过ngix不仅可以将多个请求资源进行反向代理，还可以通过配置实负载源均衡等
>
> - 反向代理，指的是通过指定的中间域名和端口，去请求服务器的资源，再通过指定的域名和端口返回我们的请求结果
> - 负载均衡指的是，当我们的资源分配在不同的服务器集群时，当用户进行访问的时候，ngix会去自动判断压力最小的服务器，从而选择该服务器作为我们的资源请求服务器
>
> ```nginx
> // 修改nginx.conf
> worker_processes 1;   //进程设置
> events {
>     worker_connections 1024;    //最大连接数
> }
> http {
>     upstream firstdemo {
>         server 39.106.145.33;
>         server 47.93.6.93;
>     }    //负载均衡集群设置
>     server {
>     listen       80;  //监听的端口
>     server_name  localhost ;
>     auth_basic off;
>     location / {
>         proxy_pass    http://firstdemo;;    //代理地址
>         proxy_set_header Host $host;
>         proxy_connect_timeout 60;   //连接超时
>         proxy_read_timeout 600;   //读取超时
>         proxy_send_timeout 600;  //发送超时
>     }
> }
> }
> 
> ```



### 前端性能优化

> - 性能优化主要可从两个方面出发下手，资源加载的体积和网络请求相关资源的速度
> - 性能分析  webpack-bundle-analyzer ，此插件可分析加载的第三方资源所占的比例
> - 资源体积：
>   - ngix                       反向代理中设置gzip代码压缩
>   - 图片体积               静态图片资源进行压缩，网站https://tinyjpg.com/
>   - treeShaking         未使用代码抖落优化，webpack4中默认支持代码摇树优化
>
> - 加载速度
>   - 组件懒加载          对于未使用的组件，懒加载，提交首屏速度
>   - 缓存                     对于静态资源进行缓存，提高服务器响应时间
>   - 雪碧图                减少图片请求次数
>   - 代码分割            将较大的第三方模块进行分割下载，提高加载速度
>   - 多线程打包       webpack内置的happyPack

https://juejin.cn/post/6904517485349830670

https://juejin.cn/post/6844904071736852487#heading-20   webpack打包性能优化

### 前端如何做团队代码质量

> 掘金好文章  https://juejin.cn/post/6844903794094899208
>
> - 代码格式统一    编写统一的config文件，约束代码格式
> - 代码提交约束   通过husky等插件，调用git中的提交钩子，并且进行检查修复

### 你的代码在那些浏览器上测试过，怎么测的，如何解决兼容问题

> 首先需要明确的是，浏览器兼容问题是必定存在的，把各个浏览器看成妃子，把用户看成皇帝，都想争个宠，总想整点不一样的让皇帝老儿开心，哈哈哈哈哈
>
> 言归正传，由于前端主要跟html css js三不类打交道，因此浏览器的兼容问题也关乎三者，如何解决呢？
>
> - css
>
>   - 当我们写的html不做任何样式时，浏览器就会加载它自定义的默认样式，然鹅，每家认为的默认样式又不一样，为了让用户使用时=统一起来，于是乎就有了样式大佬写的统一样式，国际通用normal.css 国内使用淘宝的reset.css ，目前我的项目里都用过，开锅即用！
>
>   - 别急，除过初始化，css样式兼容性问题大着呢，如果你认为这就结束了，那你太年轻了！！！，浏览器对于一些特定的css样式写法，有所不同理解，这就造成了需要给某些特定的样式写法整点特殊标记，好让浏览器知道使用这种写法我就能认识它，所谓的特殊标记，业界解决方案就是根据每个浏览器的内核，在特定写法前加浏览器内核，从而实现特定标记
>
>   - 具体实现方式有两种
>
>     - 下插件（永远是王道！）
>
>       使用VScode的伙伴们，可以直接下载postcss插件，这家伙直接可以判定你写的css有没有兼容性，如果有，它会自动给你加上浏览器兼容前缀，灰常听话！！
>
>     - webpack打包配置
>
>       第二种解决方案就是写代码的时候管他兼容性呢，正式上线的时候，在webpack中配置postcss，postcss是一个关于css的平台，内置了一个插件autoprefix，这个插件可以在打包编译的时候为特定的浏览器cs添加前缀，原理也是跟上面一样，配置前缀，具体实现方式看这篇掘金文章喽
>
>       https://juejin.cn/post/6844904017802297352
>
> - js
>
>   - js中对于很多写法，特定的浏览器不支持，不过现代化的打包工具webpack处理好了这一切，babel不仅可以将es6+的代码编译为es5，而且，还内置了polifill，对于不支持的写法进行了模拟补充

### web-worker   sevice-worker

> js是一门单线程编译语言，也就是说当主线程做事的时候，不可以去做其他的事，web-work这一api的目前可以让js在主线程编译的同时，开启后台进程，当后台进程执行完毕当前事件后，通过发送特定消息（post-message）的方式，通知主线程，以便主线程来处理此事

### 如何解决web开发中的会话追踪

> 概念理解：所谓的会话追踪就是，每次浏览器发送请求到服务器获取数据的时候，服务器总是需要判断来拿数据的这位靓仔是哪一个，总不能把张三需要的老婆娘家数据给李四需要的爱妃数据吧，这不就乱套了吗，针对这个尴尬的现状，目前业界解决方案就是cookie session以及token验证，其他三种方式都有缺陷，不推荐
>
> - 第一种 token验证（基本所有项目都在用）
>   - 实现方式：当用户登录后，后端老哥会返给你一个由字母和数字组成的字符串，没错，这玩意就是token，原理就是，除过登录注册等页面，其他所有页面，每次发送请求的时候，后端老哥接口先验证一波token，做法就是把登录拿到的token放到本地存储，或者仓库保存起来，在请求拦截中请求头上戴上token，这样从服务器拿数据时，服务器从头部远远一望，就晓得是那位靓仔，服务器就会给这位靓仔需要的数据
> - 第二种cookie和session验证
>   - 很多人还不晓得cookin和session是啥子，建议先去MDN了解一波
>   - 当浏览器第一次向服务器发起一个请求的时候，服务器会把一些关键数据保存下来，并生成一个sessio，其中就有一个sessionID，服务器返回这条请求数据的时候，也会把这个sessionID一并给浏览器，浏览器存到cookin中，当第二次浏览器请求的时候，请求头中就会戴上cooik，好让服务器识别是哪位靓仔
>   - 然鹅，这种方法有一个弊端就是，总有一些用户，担心自己的隐私数据会被泄露，一波操作，直接禁用cookie，哦豁，这种方法就夭折了
> - 第三种隐藏表单域
>   - 简单说，就是讲表单隐藏起来，用户看不见，但是却绑定了某些值，在提交的时候可以发送给后端，这样子服务器就可以识别是哪个靓仔，真的是骚！！！，不过这种方式的弊端就在于，当用户查找html节点时，依然可以发现隐藏的节点，因此这种骚操作不推荐！

### 前端如何做加密

> 前端为何要做加密，最终原因还是不安全
>
> 我们都知道http和https的区别在于，https会将浏览器传输给后台的内容进行加密解密处理，但是对于http，我们的内容并未做加密处理，一旦浏览器发送给后端的敏感内容被抓包，很有可能造成数据泄露等风险，为此在诸如注册登录等需要前端做加密处理
>
> 目前业界可用的加密处理方法很多，介绍一种相对简单，但加密层次较高的方法
>
> MD5，MD5是一种单向散列算法，也就是只可以加密，不可以解密，使用MD5暴露的方法，传入一个常量，会生成一个固定位数的编码值，此编码值唯一，不会更改，常量只要变化一点，编码值会大不一样
>
> 实际项目中，只需要引入MD5，并对用户的敏感数据进行加密，传给后台，第二次进行使用时，依然使用加密后的编码值校验即可
>
> 你以为这就完了
>
> 未完待续。。。。。
>
> 虽然MD5算法原则上不可解密，但目前已有非常多的在线网站，对于简单的密码完全可以通过穷举法和字典法轻易查到对应的MD5值
>
> 因此为了增加加密难度，我们需要在使用MD5时进行加盐salt
>
> salt是密码学中的一个改变，简单讲，当我们吃米饭的时候，加入盐，再进行搅拌，将很难将米饭和盐完全分离，salt在密码学中就是指设定一个变量或者常量，插入到一个算法结果中，这样得到的混淆结果将会增加密码难度
>
> 实际项目中可以将密码加密后，插入用户名，再次将两者结果进行加密
>
> Md5(md5(密码值)+用户名)

### 前端gzip压缩代码如何实现





## 常见的代码封装

### 防抖截流









