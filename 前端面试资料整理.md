# 前端面试资料整理

> - 基础面试题目
> - 重难点面试题目
> - 大厂面试题目
> - 算法相关的题目
> - canvas和svg   canvas的使用
>
> 

## 专业术语

#### babel转义

> babel转义是一种针对浏览器以及es不同版本语法的兼容性处理，当我们使用ES6以后的写法写的代码，某些版本的浏览器无法识别，这时babel转义就会转为ES5的语法，以便浏览器识别，同时对于不支持的某些功能，会采用polisfi进行模拟支持

#### polyfill

> 渐进式增强对的一项服务，对于低版本的浏览器需要某些新的写法或者函数，polfil可以接受浏览器发起的请求，并返回浏览器所需要的polfil
>
> 与babel的区别在于，babel是将高版本的js写法，通过转义成AST代码树，然后解析成低版本的写法



## html

### 前端seo，单页面下如何去做seo

> SEO指的是搜索引擎网站对网站的搜索比重
>
> 单页面（前端三大框架全部为单页面）在百度中不予收录
>
> 目前单页面所做的seo处理有两种优化方案
>
> - 首页采用服务器渲染
> - 服务器判断访问的是浏览器还是爬虫服务器，如果是爬虫，交给prerender处理，prerender是谷歌和必应推荐的做seo优化的预呈现插件
> - 进行转发代理，代理处理后，返回给爬虫服务器seo的相关信息
> - 知乎案列   https://zhuanlan.zhihu.com/p/36241703



### 你做过哪些浏览器的兼容，怎么做的

> 不同的浏览器有不同的内核，这就导致，html css js在不同的浏览器上有时会解析出不同的效果，为了使得效果统一，css通常在浏览器前加前缀，目前所有的前端框架均通过插件“auto-profixer”来自动添加前缀，从而解决前缀问题

### html头部的doctype的作用

> 当页面添加这个头部时，意在告诉浏览器，这是标准模式解析
>
> 浏览器可以加载<u>**标准模式**</u>和<u>**怪异模式**</u>
>
> 两者的区别在于两者对于宽度width的定义不同，标准模式下，元素在页面中所占的宽度为padding+width+margin+border
>
> 怪异模式下width=padding+border. 实际上页面所占的距离只有width+margin

### div+css 和table布局的特点，各自的优点

> div+css 遵循结构和表现分离原则，通常更换css样式就可以更换整个网站风格
>
> div+css 可以边加载边显示，相对于表格的完全加载完才可以显示而言，加载速度更快
>
> div+css 可以通过布局来实现部分数据的较快加载，典型的如圣杯布局
>
> 相对而言，代码结构清晰，后期更容易维护

### img的alt和title有什么异同

> title是每一个元素都共有的属性，可以设置title来提示元素设置的特殊化信息
>
> alt为图片特有的属性，当图片资源加载异常时，会用设置的alt信息来替代
>
> seo中设置图片alt的属性会增强seo

### 优雅降级和渐进增强

> 可以理解为程序设计的两种模式，优雅降级主要是在高级运行中向下兼容，如vue react的babel转义
>
> 渐进增强为向上逐渐高级的写法，如jquery中使用vue

### 为何要使用多个域名来保存网站资料，cdn是什么

> cdn是指针对某一资源，加载离用户最近的服务器资源网络
>
> 可以减少主服务器的压力，增加并发量，防止不必要的数据丢失等

### cookie localstorage sessionStorage  session的区别

> 区别 前三者均存在客户端，也就是浏览器上，session存放在服务器上

##### cookie

当用户第一次向某个服务器发起请求时，浏览器和服务器就会建立一次对话连接，在服务器端生成一个session，

同时向浏览器返回cookis值，主要保存关于用户登录状态的一些重要信息（账户，密码，停留时间等），其中包含一个sessionID，cookis也可以设置生效时长，如不设置，则默认为关闭浏览器失效，之后，当客户端每次向服务器发起请求时，请求头中都会携带cookis，以让服务器端来验证用户的登录信息，以及相应对应的数据等，由于每次都可以携带cookis发起请求，因此客户端限制cookis只能携带4k的东西，当然为了节省宽带，降低服务器的消耗，cookis中一般存放一些重要的信息，其他的都存放在cookis中

##### localstorage

这是浏览器新支持的存放方式，客户端可以使用set和get方法，对其进行存取，原则上，loacl中存储的东西可以永久保存

##### sessionstorag

sessionstorge存在于页面与页面所建立起的对话，当浏览器关闭的时候，sessionstorage就会消失

##### session

session为服务器端存放的数据，主要保存用户的一些基础信息，同时可以对cookis的值进行更新

### h5的离线缓存

> 参考文章 https://zhuanlan.zhihu.com/p/70883817
>
> 实现原理就是html文件中，设置minfest属性，浏览器通过minfest属性，去解析需要缓存什么内容，从而达到浏览器断网后也可以缓存的效果
>
> 实施步骤
>
> - 设置html头
>
>   - ```html
>     <!DOCTYPE html>
>     <html lang="en" manifest="demo.appcache">
>     <head>
>         <meta charset="UTF-8">
>         <title>demo</title>
>     </head>
>     <body>
>         <img src="img.jpg" height="500" width="900" alt="">
>         其它内容...
>     </body>
>     </html>
>     ```
>
>     manifest 文件可分为三个部分：
>
>     - CACHE - 在此标题下列出的文件将在首次下载后进行缓存。
>     - NETWORK- 在此标题下列出的文件需要与服务器连接，且不会被缓存。可以使用*，表示除CACHE 外的所有其他资源/文件都需要因特网连接。
>     - FALLBACK- 在此标题下列出的文件规定当页面无法访问时的替代页面。
>
> - 检索需要设置缓存的资源
>
>   - ​	
>
>     ```html
>     CACHE MANIFEST
>     #version 1.0
>     CACHE：
>         img.jpg
>     NETWORK:
>         *
>     FALLBACK:
>         /demo/ /404.html
>     ```
>
> - **操作window.applicationCache进行需求实现。**
>
>   - ```js
>     unction handleCacheEvent(e) { 
>             对应操作...
>         } 
>         function handleCacheError(e) { 
>            alert('Error: Cache failed to update!'); 
>         }; 
>         //在浏览器为应用缓存查找更新时触发
>         oAppCache.addEventListener('checking', handleCacheEvent, false); 
>         //在检查描述文件发现文件无变化时触发
>         oAppCache.addEventListener('noupdate', handleCacheEvent, false); 
>         // 在开始下载应用缓存资源时触发
>         oAppCache.addEventListener('downloading', handleCacheEvent, false); 
>         //在文件下载应用缓存的过程中持续不断地下载地触发
>         oAppCache.addEventListener('progress', handleCacheEvent, false); 
>         //在应用缓存完整可用时触发 
>         oAppCache.addEventListener('cached', handleCacheEvent, false); 
>         //在页面新的应用缓存下载完毕触发
>         oAppCache.addEventListener('updateready', function(){
>               oAppCache.swapCache();// 更新本地缓存
>               location.reload();    //重新加载页面页面
>             }, false); 
>         //在检查更新或下载资源期间发送错误时触发
>         oAppCache.addEventListener('error', handleCacheError, false); 
>         //缓存清单不存在时触发
>         oAppCache.addEventListener('obsolete', handleCacheEvent, false); 
>     ```
>
> - **在服务器端正确的配置MIME-type。**
>
>   - 在tomcat服务器中的conf/web.xml中添加：
>
>     ```html
>     <mime-mapping>
>         <extension>manifest</extension>
>         <mime-type>text/cache-manifest</mime-type>
>     </mime-mapping>
>     ```

### src和href的区别



> src英文直译过来就是加载资源的意思，顾名思义就是引入外部链接，一般会使得浏览器停止当前行为，来运行这一加载资源的行为
>
> href指的是网络资源中的位置，是元素和文档之间的链接关系
>
> 因此，**js脚步使用src来引入时，就不可以放入头部，会导致页面的阻塞加载，这也是为什么推荐css样式使用link 引入的原因**

### 网页中的使用的图片

> 根据我们使用的使用经验，目前将图片分为三类，**<u>透明图层，不透明图层，动图，矢量图</u>**
>
> 其中透明图层为png，动图为gif，不透明为jpg，jpeg，webp格式，矢量图为svg
>
> 目前最优的图片则是webp，这是由谷歌公司创建的新图片格式，比jpg体积更小，显示更为清晰，不过webp兼容性不是很好，使用时需要判断当前浏览器是否支持webp格式
>
> 常见的压缩图片的网站  tinyPng  谷歌的Squoosh（无法进行批量转换）

### 热点地图是什么













## css

### 移动端1px问题

> 当移动端设置1px的时候，实际设置的1个物理像素，当手机像素较高时就会出现边框较粗的现象
>
> 解决方案：
>
> - 第一种办法   判断设备的物理像素，根据物理像素对边框值进行缩放处理
>
> ```css
> .foo {
>   /* Output example */
>   .test {
>     border: 1px solid #000;
>     @media (min-resolution: 2dppx) {
>       .test {
>         position: relative;
>         border: none;
>       }
>       .test::before {
>         content: '';
>         position: absolute;
>         left: 0;
>         top: 0;
>         width: 200%;
>         height: 200%;
>         border: 1px solid #000;
>         border-radius: 0px;
>         transform-origin: 0 0;
>         transform: scale(0.5);
>         box-sizing: border-box;
>         pointer-events: none;
>       }
>     }
>     @media (min-resolution: 3dppx) {
>       .test::before {
>         width: 300%;
>         height: 300%;
>         border-radius: 0px;
>         transform: scale(0.33);
>       }
>     }
>   }
> }
> ```
>
> - 第二种办法  直接引入postcss-1px-border第三方插件解决

### css hack

> Css hack是指，针对不同的浏览器，使用不同版本可以识别的特殊符号，从而实现不同版本浏览器下，加载不同的样式效果

### 快级和行级元素的区别

> - 快级元素独占一行，padding和marging全部有作用
> - 行内级别，水平方向排列，上下内边距和上下外边距设置无效
> - 两者可以通过display=block和display=inner-block相互转换

### 什么是空元素

> HTML中有三类元素，快级 行内，空元素
>
> 其中空元素指的是html中不能存在子节点的元素
>
> 常用的空元素有img input textarea meta等

### 什么是外边距重叠，重叠的效果是什么？

> 外边距重叠是指，当两个元素盒子元素在设置外边距的时候，重合的一端会产生值的合并
>
> - 两个都是正值时，取最大的
> - 两个都是负的时，取绝对值最大的
> - 两个一正一负时，取两个的和

### css中水平和垂直重叠可以用什么来实现

> - 垂直方向可以用line-height，当和height一样时，会实现垂直居中效果
> - 水平方向可以用letter-spaceing，当设置负值时，会将元素重叠

### px em rem vw vh 单位的区别

> px是像素单位，pc端开发中经常使用这个单位
>
> em是指相对于父亲设置font-size，而且会根据父亲的字体大小，来调整自己的大小
>
> rem是指相对于body根元素设置font-size，这样可以实现所有的元素大小根据body来改变大小，通常app端，使用这一方案，实现不同的手机兼容
>
> vw和vh是视窗宽度和视窗高度，是指在整个设备的视窗中，可以设置不同比例，100vw和100vh将会占满整个屏幕

### css预编译器，react中用什么方案解决更好

> css预编译器是css语法的增强版，可以让原生的css实现代码更好的继承复用，采用变量书写css等
>
> less与sass都可以实现此类功能
>
> vue中采用css预编译，可以让文件作用于当前css
>
> react要实现这样的效果，目前官方推荐css in js，防止全局污染

### BFC 快级上下文

> BFC会形成一个快级渲染盒子，盒子内的布局不会影响盒子外的布局，有点类似于js的作用域名
>
> 其中，display=block inner-block position=abroute fied 都会形成BFC





## js

### 作用域

- 计算机通过对三种命名变量或者方法 对象的方式来进行解析语法，形成AST语法树，从而确定它可以作用的空间领域   es5：var   es6:let const

### js数据类型

#### 基础数据

- js包含七种类型。null underfined string number   boolber   object  Sybil 
- null属于object类型 object下有数组 对象 函数三个子类型
- 数组可以直接通过 arr【索引】取值  但是，对于不存在的索引，数组的值将会是underfine
- 字符串前添加+号，可以转换为数字

#### 引用数据类型

### js如何准确无误的判断数据类型

> type of    可准确判断数字，字符串，布尔值，undefinde     数组，对象，null会显示位object，函数会显示会function
>
> Instace of  适合判断object对象的值
>
> constract
>
> 通用的方法 采用object.prototype。toString.call 会返回一个【object 数据类型】从而来判断数据类型

### js中的this指向改变问题，call aply bind

> - 三者都可以通过改变this指向，从而达到调用其他方法的目的
> - Call和apply的区别在与传参方式不同，两者都是立即调用
> - call的用法       被调用方法.call( 要调用的方法.参数1，参数2，参数2，。。。。。   )
> - apply的用法     被调用方法.call( 要调用的方法.【参数1，参数2，参数2，。。。。。 】 )
> - bind的用法    被调用方法.bind( 要调用的方法.参数1，参数2，参数2，。。。。。  ) ()
> - 注意bind不是一个立即调用方法，必须调用才可以使用

### js中的继承

> js中的继承可以分为原型链继承，类对象继承，混合试继承

### 异步编程 promise

- 

### this指向

### 对象原型

## vue

## react

## 计算机综合知识

### 从用户刷新网页开始，我们可以使用哪些缓存来对页面进行优化

> 如果需要了解有哪些缓存方式，需要从一个url输入到最后拿到资源整个过程去分析
>
> - 第一步：当我们输入搜索关键字的时候，浏览器需要先通过DNS去解析我们输入的内容，从而找到文件所在的ip地址，这一过程就是DNS解析，这一过程就会存在<u>**DNS缓存**</u>，浏览器会保存我们第一次的搜索内容和对应的ip，当第二次搜索同样的内容时，就不会直接去服务器获取ip，会通过DNS缓存拿起id地址
> - 第二步：第一步拿到ip地址后，浏览器会和服务器发起会话请求，当我们需要的内容有CDN分发时，首次请求会通过CDN服务器向主服务器发起请求，获取数据，第二次时，浏览器会通过CDN服务器缓存的数据拿取，这一过程就是**<u>CDN缓存</u>**
> - 第三步：第二步拿到资源后，浏览器会根据ip地址和请求参数，去获取数据，这时如果服务器设置了强缓存，服务器将会在首次加载资源的时候，返回expire或者catch-thre ，两者可以同时设置，这样，浏览器在下次请求资源资源时，会先去查找缓存的内容，当缓存不存在的时候，才会去服务器获取相关资源
>
> 浏览器中from memory catche和from disk cache的区别
>
> - from memory catche是指从内存中获取缓存的资源，当页面关闭后，资源也会随之释放
> - from disk cache是指从磁盘中获取缓存的资源，页面关闭后，资源仍然存在，状态码为304，即服务器资源没有更新，加载本地资源

### 图片的懒加载

> 当网站有大量的图片需要加载时，如果一次请求所有的图片资源，将会造成白屏和资源浪费，我们可以懒加载图片，
>
> 实现方式就是采用自定义的图片src，当滚动内底部时，将自定义的图片资源给到真实的图片src中
>
> 实际项目中可以引入第三方包https://www.npmjs.com/package/load-js，来解决这一问题，放心用吧，大大大厂都在用的！

### 前端跨域处理   ngix

> ngix为目前处理跨域问题的主要解决方案，通过ngix不仅可以将多个请求资源进行反向代理，还可以通过配置实负载源均衡等
>
> - 反向代理，指的是通过指定的中间域名和端口，去请求服务器的资源，再通过指定的域名和端口返回我们的请求结果
> - 负载均衡指的是，当我们的资源分配在不同的服务器集群时，当用户进行访问的时候，ngix会去自动判断压力最小的服务器，从而选择该服务器作为我们的资源请求服务器
>
> ```nginx
> // 修改nginx.conf
> worker_processes 1;   //进程设置
> events {
>     worker_connections 1024;    //最大连接数
> }
> http {
>     upstream firstdemo {
>         server 39.106.145.33;
>         server 47.93.6.93;
>     }    //负载均衡集群设置
>     server {
>     listen       80;  //监听的端口
>     server_name  localhost ;
>     auth_basic off;
>     location / {
>         proxy_pass    http://firstdemo;;    //代理地址
>         proxy_set_header Host $host;
>         proxy_connect_timeout 60;   //连接超时
>         proxy_read_timeout 600;   //读取超时
>         proxy_send_timeout 600;  //发送超时
>     }
> }
> }
> 
> ```



### 前端性能优化

> - 性能优化主要可从两个方面出发下手，资源加载的体积和网络请求相关资源的速度
> - 性能分析  webpack-bundle-analyzer ，此插件可分析加载的第三方资源所占的比例
> - 资源体积：
>   - ngix                       反向代理中设置gzip代码压缩
>   - 图片体积               静态图片资源进行压缩，网站https://tinyjpg.com/
>   - treeShaking         未使用代码抖落优化，webpack4中默认支持代码摇树优化
>
> - 加载速度
>   - 组件懒加载          对于未使用的组件，懒加载，提交首屏速度
>   - 缓存                     对于静态资源进行缓存，提高服务器响应时间
>   - 雪碧图                减少图片请求次数
>   - 代码分割            将较大的第三方模块进行分割下载，提高加载速度
>   - 多线程打包       webpack内置的happyPack

https://juejin.cn/post/6904517485349830670

https://juejin.cn/post/6844904071736852487#heading-20   webpack打包性能优化

### 前端如何做团队代码质量

> 掘金好文章  https://juejin.cn/post/6844903794094899208
>
> - 代码格式统一    编写统一的config文件，约束代码格式
> - 代码提交约束   通过husky等插件，调用git中的提交钩子，并且进行检查修复

### 你的代码在那些浏览器上测试过，怎么测的，如何解决兼容问题

> 首先需要明确的是，浏览器兼容问题是必定存在的，把各个浏览器看成妃子，把用户看成皇帝，都想争个宠，总想整点不一样的让皇帝老儿开心，哈哈哈哈哈
>
> 言归正传，由于前端主要跟html css js三不类打交道，因此浏览器的兼容问题也关乎三者，如何解决呢？
>
> - css
>
>   - 当我们写的html不做任何样式时，浏览器就会加载它自定义的默认样式，然鹅，每家认为的默认样式又不一样，为了让用户使用时=统一起来，于是乎就有了样式大佬写的统一样式，国际通用normal.css 国内使用淘宝的reset.css ，目前我的项目里都用过，开锅即用！
>
>   - 别急，除过初始化，css样式兼容性问题大着呢，如果你认为这就结束了，那你太年轻了！！！，浏览器对于一些特定的css样式写法，有所不同理解，这就造成了需要给某些特定的样式写法整点特殊标记，好让浏览器知道使用这种写法我就能认识它，所谓的特殊标记，业界解决方案就是根据每个浏览器的内核，在特定写法前加浏览器内核，从而实现特定标记
>
>   - 具体实现方式有两种
>
>     - 下插件（永远是王道！）
>
>       使用VScode的伙伴们，可以直接下载postcss插件，这家伙直接可以判定你写的css有没有兼容性，如果有，它会自动给你加上浏览器兼容前缀，灰常听话！！
>
>     - webpack打包配置
>
>       第二种解决方案就是写代码的时候管他兼容性呢，正式上线的时候，在webpack中配置postcss，在打包编译的时候webpack会自动处理兼容性，原理也是跟上面一样，配置前缀，具体实现方式看这篇掘金文章喽
>
>       https://juejin.cn/post/6844904017802297352
>
> - js
>
>   - js中对于很多写法

### web-worker   sevice-worker

> js是一门单线程编译语言，也就是说当主线程做事的时候，不可以去做其他的事，web-work这一api的目前可以让js在主线程编译的同时，开启后台进程，当后台进程执行完毕当前事件后，通过发送特定消息（post-message）的方式，通知主线程，以便主线程来处理此事



## 常见的代码封装

### 防抖截流









