# 浏览器知识汇总

## 一,浏览器组成

### 1.浏览器概念

浏览器可以理解为解析来自服务器内容的一个终端，自己本身具有发送和接收数据，解析数据的能力，为了网络世界收发数据的实现，世界 W3C 机构制定了一些基本的关于浏览器的规则，但是各家浏览器为了突出自家卖点，均有一些不同的规则。

### 2.浏览器内核

各家浏览器独特的卖点就是自己的内核，所谓的内核主要由两部分组成，1 部分是渲染引擎，主要用来解析 HTML，XML，绘制 CSS 样式等，2 部分就是解析和运行 JS 的引擎

### 3.浏览器兼容问题处理

根据上述对浏览器的介绍，我们知道浏览器之间的兼容问题必不可少，但是对于用户来讲，是完全不理解这些个家伙为何要这样做的，因此对于开发者来说，我们就是要帮助用户解决这个问题。

兼容性问题主要体现在两个方面

- 各家浏览器对 CSS 的解读
  实际项目中，我们会结合 webpack 等打包工具，对于我们写的 CSS 文件，添加 postcss 支持，postcss 会对每一个不兼容的 CSS 样式，针对各家浏览器添加内核前缀，以达到统一兼容效果

- 各家浏览器对解析 JS 的行为
  实际项目中，结合 babel 和 poslifill，对浏览器的具体 JS 解析功能做统一处理

## 二,浏览器渲染原理

![zNejm.png](https://s1.328888.xyz/2022/06/08/zNejm.png)

> 当浏览器接收到服务器的 html，css，js 等文件时，会同时根据 HTML 来生成文档模式，根据 CSS 生成 CSS 样式规则表，然后再结合两者生成渲染元素，再根据渲染元素的位置进行布局后，展示出来，这个过程会循环持续，直到所有加载完毕，为了不造成卡顿的错觉，浏览器会分段做这个行为，内容也会一点点展示出来，而不是等到所有布局完成再解析，这会造成阻塞。

### 1.哪些行为会造成浏览器的渲染阻塞，如何避免？

> 浏览器渲染主要就是与 HTML，CSS，JS 相关，那么我们从三个方面下手解决渲染阻塞。

#### HTML

> 浏览器页面的主要展示就是关于 html，但是当 HTML 的层级过多时，浏览器的解析就会变得缓慢，结合实际情况，我们在 VUE 或者 REACT 开发时，可以使用框架提供的空标签，空标签并不会产生新的 DOM 层级

#### CSS

> CSS 的解析并不会阻塞渲染，但是 CSS 操作会引起浏览器的回流和重绘，因此我们应当尽量避免这类高消耗行为

#### JS

> 当浏览器遇到 JS 时，会暂停 HTML 的渲染，直接去下载和运行 JS 文件，执行完毕后，再去渲染被中断的 HTML，因此 JS 会导致浏览器渲染阻塞，实际开发中，结合 webpack 等打包工具，往往将 JS 放在 body 最后解析运行，同时设置 defer 属性，实际上有两种异步加载的方式，async 和 defer，但推荐用 defer，async 会异步下载，无论 HTML 是否解析加载完毕，会立即去执行，多个 async 无法保证执行顺序，defer 也是异步下载，但是 defer 会让 HTML 解析完毕后再去执行，多个 defer 会按照顺序执行

## 三,浏览器同源策略

### 1.什么是同源策略

浏览器为了安全起见，对于协议，域名，端口不同的请求全部视为跨域请求
![zVHn0.png](https://s1.328888.xyz/2022/06/08/zVHn0.png)

### 2.如何解决同源策略导致的跨域问题

实际开发过程中，当我们调用 API 时，肯定会遇到跨域问题，为什么呢，因此我们开发中，前端的域名是自己本机的 IP 地址，后端的 API 是后端同事电脑的 IP 地址，两者触发了同源策略，所以会出现跨域问题，项目上线后，前后端是部署在同一台服务器或者虚拟机上，便不会出现跨域问题.

> react 项目中的跨域问题可以使用 midwarepoxy 来解决，详细解决方案不多说，百度即可。

### 正向代理和反向代理的区别

#### 1.正向代理

VPN 访问就是正向代理，我们无法访问 BBC，需要借助 VPN 服务器访问 BBC 后，我们再去从 VPN 服务器上获取数据

#### 1.反向代理

NGinx 负载均衡就是反向代理，目的是将用户的请求分发到不同的服务器，降低主服务器压力，同时隐藏主服务器 IP

## 四,浏览器安全

### 1.有哪些可能引起前端安全的问题？

- iframe 的使用
  iframe 可以嵌入到正常的网页中，形成一个天然的隔离沙盒，其中沙盒内如果有恶意获取用户信息的脚本，则会造成安全风险。
- 第三方类库的使用
  当前无论前后端，都使用了大量的第三方库，如果第三方库中有恶意脚本，也会造成安全风险
- 跨站脚本
  早期的论坛等地方，用户可以在输入框中输入 js 脚本正常运行，当前现代化框架中，对于 JS 的脚本等都会进行转移，已经大大降低了这类攻击。

### 2.XSS 攻击

XSS 是指服务端返回的数据中，前端进行拼接，到 HTML 中渲染运行，早期的框架中会存在这样的风险，现代化框架出来后，都会对这样的输入做框架级的转移，不过仍然有一些安全措施可以让开发人员来控制。

- 设置 http-only
  服务端设置 http-only，这样前端无法读取和操作 coookie，保证了一定的安全性
- dangerouslySetInnerHTML
  react 中对于一些有安全风险的渲染采用 dangerouslySetInnerHTML 来进行渲染，框架会做一定的安全校验

### 3.CSRF 攻击

CSRF 攻击指的是获取用户的 cookie，拿到 cookid 后代替用户做一些非法操作，如何防止 CSRF 攻击呢，从攻击手段出发，首先是避免前端获取 cookid，设置 http-only 属性，其次，如果浏览器保存的 cookie，并不会被服务器使用的时候，CSRF 攻击就不攻自破，当前，可用 JWT 手段去防止 CSRF 攻击。

### 4.什么是 JWT？

JWT,单词 JSON Web Token，如何生成，具体又包含什么信息呢？

> JWT 的生成过程
>
> > [![Xs4Cmq.png](https://s1.ax1x.com/2022/06/09/Xs4Cmq.png)](https://imgtu.com/i/Xs4Cmq)

> JWT 包含的信息
>
> > [![Xs5GV0.png](https://s1.ax1x.com/2022/06/09/Xs5GV0.png)](https://imgtu.com/i/Xs5GV0)

#### JWT 相比传统的 sessionID 保存用户信息方案的优点是什么？

> 首先说明一点，两者都是用于保存用户登陆信息，方便用户访问具体服务的方式。

> 先来看看两者的实现方式

> 传统的 session 保存用户信息的方式：用户成功登陆某个网站服务后，将用户名字和密码以及其他用户信息传递给后端，后端将其保存下来，由于用户不止一个，所以为了区别具体的用户，后端将用户信息保存到 redis 等内存中后，会生成一个 id，这个 id 就是我们所谓的 sessionID，后端会将这个 sessionID 存在响应中，客户端拿到这个 sessionID 后，保存到请求头的 cookie 中，每次请求的时候都带上这个 cookie，后端再通过这个 id 去查找具体的用户信息，再进行操作，这样有什么缺点呢，1 每次客户端访问服务端，都需要对 sessionID 进行查找，消耗性能 2 当用户开启了无痕模式后，浏览器无法带上 cookie，解析失败！

> 再来看 JWT，依然是用户登陆，后端将前端给的用户信息用具体的算法加密，一般为 sha256 加密，然后将加密后的 JWt 返给前端，前端保存到 local 本地存储中，在请求拦截中在请求头上添加和后端约定的请求头字段，值就是这个加密的 JWT，后端再次拿到这个 JWT 后，无须查找，只需要进行解密后就可以拿到用户的信息，节省了查询，也绕开了用户的无痕浏览，同时，从安全角度出发，这样的做法绕开了浏览器的 cookie 解读，也就从一定角度上解决了 CSRF 攻击的风险。

### 5.网络劫持是什么？通常有哪些网络劫持的方式？

> 网络劫持是指对用户发出的网络请求进行拦截，之后对响应的数据或者地址进行修改再返回给用户.

> 通常存在两类网络劫持。

- DNS 域名解析劫持
  我们都知道，我们的每一次搜索，必然都会经过 DNS 域名解析，那么当 DNS 恶心将我们输入的淘宝解析到京东的时候，这就造成了恶意劫持，当然目前已经被全面禁止。

- http 网络请求传输劫持
  http 协议下的传输每一次都是明文传输，那么当运营商便可以针对响应的内容进行改造，比如添加广告等，这样也会造成劫持，避免这一情况可以采用 https 的方式，加密传输。

## 五,浏览器的缓存管理

[![XsLyCt.png](https://s1.ax1x.com/2022/06/09/XsLyCt.png)](https://imgtu.com/i/XsLyCt)

> 从 http1.0 到 http2 浏览器经历了四种缓存方案，可以说逐步完善了缓存机制，目前主要区分为强缓存和协商缓存。

### 强缓存

> Expires===>http1.0 中有个响应字段 Expires，资源第一次被请求成功后，浏览器读取这个绝对响应时间，并且将资源缓存起来，下次请求时，发现本地时间在缓存时间内，直接返回本地的缓存，这个缓存方案的缺点就是客户端更改了本地时间后，响应就会失效。

> Cache-Control===>http1.1 中优化了上述方案，提供了更为丰富的缓存响应字段 Cache-Control，这个响应字段可以设置 private（不允许代理服务器，如 CDN 等缓存），no-ache（每次必须请求服务器来确认资源是否过期），max-age（相对时间，即使修改客户端时间也于事无补）

### 协商缓存

> 强缓存失败后，会启用协商缓存

> 先来思考上述的 cache 的强缓存有什么问题，思考一个场景，实际开发中，有很多内容，后端会保存在 redis 等的内存管理中，当客户端去服务端请求数据时，如果数据库相关内容已经更改，而 redis 并未读取到最新的内容，这时缓存就会失效，来看下新的缓存方案如何解决这一问题呢？

> Last-Modified===> http1.1 响应体中缓存属性 Last-Modified，指的是资源最后一次修改的时间，精确到秒级，当客户端下一次发起请求时，浏览器请求头上会携带 If-Modified-Since，这个值就是上一次返回的文件修改时间，在缓存时间内就可以使用缓存，思考一个问题，如果一个内容在 1 秒内更新了多次，那么就无法检测到缓存，所以继续看下一个缓存方案

> Etag===> http1.0 响应体中缓存属性 Etag，指的是资源文件的特殊标记值，当文件被修改后，这个标记值就会更改，客户端下一次请求时，在请求头上带上 If-None-Match，值就是上次响应体中的 Etag，如果标记值未更改就使用缓存的数据，实际开发中，借助 webpack 等打包工具，可以指定每一个文件打包后的 hash 值，文件更改后，hash 值便会更改

- 当然缓存并不是用的越多越好，对于静态资源可以考虑使用缓存，当做负载均衡，存在多个服务器集群时，最好不要设置 Etage 属性，因此每个服务器上的 Etage 都不一样

## 六,浏览器垃圾回收

浏览器的垃圾回收与 JS 的垃圾回收机制相似，具体详情可前往 JS 部分查看 JS 的垃圾回收
