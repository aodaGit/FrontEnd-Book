# JS

## 数据类型

> js 包含七种类型。null underfined string number boolber object Sybil，biginit

### 基础数据

- 基础数据类型包括 字符串 数字 布尔值 null undefinded
- 基础数据类型存放在栈中
- null 属于 object 类型 object 下有数组 对象 函数三个子类型
- 数组可以直接通过 arr【索引】取值 但是，对于不存在的索引，数组的值将会是 underfine
- 字符串前添加+号，可以转换为数字
- 字符串与数字前加！！可以转换为布尔值

### 引用数据类型

- 引用数据类型包括： 数组 对象
- 由于引用数据类型的空间是不确定的，因此引用数据在存放数据时，会将指针存放在栈中，值存放在堆中

### js 如何准确无误的判断数据类型

> type of 可准确判断数字，字符串，布尔值，undefinde 数组，对象，null 会显示位 object，函数会显示会 function
>
> Instace of 适合判断 object 对象的值
>
> constract
>
> 通用的方法 采用 object.prototype。toString.call 会返回一个【object 数据类型】的字符串，从而来判断数据类型

### js 中的对象中的 key 可以为其他类型吗？

只能是字符串和 Sysmbol 类型

### JS 精度丢失问题

产生这个问题的根本原因在于

实际项目中，JS 运算总会存在精度问题，原因是 JS 数据在计算时总是以 2 进制进行计算，但是 JS 中的所有数组在表示时 却是以 10 进制表示，因此表现为部分小数位存在差异，实际中使用 bigNumber.js 解决

### js 中 null 和 underfined 的区别

> 简而言之，这是一个历史遗留问题，null 和 uniderfinde 都可以表示不存在的值，只是 null 表示丢失的对象，underdined 声明了，但是未赋值时
>
> 检测类型中 typeof null 为对象 typeof underdinded 为 underfinde

### sysbol 的使用场景

> sysbol 为 es6 新的数据类型，通过 sysbol（）方法可以得到一个独一无二的值
>
> 根据此特征，我们可以的主要使用场景可以为独一无二的变量值的设定

## JS 基础

### map 和 object 的区别

### 延迟加载 JS 脚本的方法

- 将 JS 脚本放在 body 后解析，原因在于 src 的引入方法会阻塞文档的解析，因此放在最后，等待 dom 加载解析完后再执行 js 文件
- 给引入的 JS 文件设置 defer 属性，defer 能够使得

### 类数组和数组的区别，如何相互转换

类数组与数组相似，都拥有 length 属性，但是类数组不存在数组的一些默认方法，类数组可以调用 Array.form(类数组)转换为数组

### 数组有哪些常用的原生方法

let array=[1,2,3,4,5,6567,4343,'432432']

- every

```ts
// 对数组中的每一个item进行条件性比对，结果是一个布尔值
array.every((item) => item > 7);
 => false;
```

- some

```ts
// 对数组中的每一个item进行条件性比对，只要有一个符合条件的就会终止查询，结果是一个布尔值
array.some((item) => item > 7);
 => true;
```

- map

```ts
// 对数组中的每一个item进行操作，并且返回一个新的数组
array.map((item) => {
  const obj={}
  obj.value=item
  return obj
});
 => [ {value:1},{value:2},{value:3}....  ];
```

- includes
- find
- filter
- push
- sort 排序
- shift

### 数组的 reduce 方法

reduce 被称之为数组中最高级的用法，reduce 接收四个参数，最常用的做法就是接受一个更改累计值的回调和一个默认的初始值

> 以下所有示例中 t 代表最终输出结果的集合，cur 代表当前遍历到 item

1.累加或累乘

```ts
// 累加
let a = [1, 23, 4, 5, 5];
a.reduce((t, cur) => t + cur, 0);
// 累乘
a.reduce((t, cur) => t * cur, 1);
```

2.替代 数组 map 方法

```ts
let a = [1, 23, 4, 5, 5];
a.reduce((t, cur) => [...t, { value: cur }], []);
```

3.替代 数组 every 方法

```ts
let a = [1, 23, 4, 5, 5];
a.reduce((t, cur) => t && cur > 8, true);
```

4.替代 数组 some 方法

```ts
let a = [1, 23, 4, 5, 5];
a.reduce((t, cur) => t || cur > 8, false);
```

5.查找数组中最大值

```ts
let a = [1, 23, 4, 5, 5];
a.reduce((t, cur) => (t > cur ? t : cur));
```

6.查找数组中最小值

```ts
let a = [1, 23, 4, 5, 5];
a.reduce((t, cur) => (t < cur ? t : cur));
```

### 数组去重

#### 常用的三种方法

- 利用 Set 数据类型实现数组去重
  [...new Set(具体数组数据)]

- 数层双层遍历

  将数组数据遍历，采用一个新的数组接收后续的不重复数组

### arguments 为何不是不能用数组的方法，如何更改可以使用数组的方法？

arguments 指的是一个函数所有参数组成的类数组，实际上是一个由 0 开始递增的对象，可以使用 Array.from 或者使用扩展运算符号转换后，就可以使用数组的方法进行操作

### ajax 发送请求的过程，手动实现一个 ajax 请求

### fetch,ajax,axios 的区别

- fetch 和 ajax 都是浏览器原生发起异步请求的解决方案
- fetch 为 es6 后推出，号称是 ajax 的替代品，基于 promise，支持 async，await，但是在服务端返回的 400 和 500 的状态并不会去 reject
- axios 为兼容浏览器和 node 端的一个 http 请求库，基于 promise，具有请求拦截，响应拦截，动态设置请求头，请求次数限制等高可用功能

## ES6

### var let const 的区别

> 三者都是 js 中用来解析变量的标识符
>
> > var 声明的变量，会被提升到作用域最前端，也就是即使变量在执行顺序后，变量也会被提升到最前面，并且 var 声明的变量是挂载到全局变量即 windows 或者 global 上面
> >
> > Let 声明的变量会形成一个快级作用域，也就是只可以在声明后执行，并且不可重复声明，可重复敷值，可不设置初始值
> >
> > Const 声明的变量也会形成一个快级作用域，区别在于 const 声明的变量会形成常量，不可再次进行声明和赋值（基本不可，引用可增加键值），如果让一个对象不可更改，不可增加键值，可用 object.fressze（）将对象进行冻结

### 箭头函数与普通函数的区别

> 语法更为简洁。 ()=>{}
>
> 箭头函数没有 protype
>
> 箭头函数不可以使用 this，箭头函数的 this 指向的是定义时外向的第一个对象
>
> 箭头函数不能获取 argments，可以使用剩余参数实现
> 通过 call。apply，bind 方法也不能改变箭头函数的 this

### new 一个箭头函数

箭头函数不存在 protype,不存在 this 指向，也不存在 angrs 参数，因此不可以 new 一个箭头函数

### new 一个对象发生了什么？

### 扩展运算符的使用

#### 数组扩展

```ts
// 1.使用数组扩展快速合并数组
let a = ["1", "2"];
let b = ["3", "4"];
let c = [...a, ...b][("1", "2", "3", "4")];
// 2.使用数组扩展结构特定数组
let a = [1, 2, 3, 4];
const [params, ...rest] = a;
params; // 1
rest; // 2 3 4
```

#### 对象扩展

```ts
// 1.替换对象中的数据
let person = { name: "前端学点啥", age: 20 };
const newPerson = { ...person, name: "前端一直学" };
const newPerson = { ...person, ...{ name: "前端一直学" } };
```

#### 字符串扩展

```ts
// 1.快速将字符串切割为单个字符组成的数组
let title = "前端学点啥";
const titles = [...title];
```

### 对数据进行排序

### ES6 中的 reduce 方法使用

### JS 中的对象如何创建不重复的键值

1. symbol 创建键
2. 使用 weakMap 数据类型

## 原型和原型链

- JS 本身是一本基于原型而设计的语言，原因在于原型设计模式下，可以将这门语言达到高扩展，高复用的目的。
- 从 JS 的基本数据就可以看出

```ts
// 使用语法糖快速生成一个字符串
let value = "前端一直学";
// value 实际上是由JS中的String构造函数生成，value在创建的同时就创建一个隐式的原型，这个隐式原型指向于String的显示原型protype，当我们在让value调用字符串相关的方法时，实际会去查询自身的隐式原型，当查询不到时会去查找它的构造函数，以及构造函数的原型，最终会查找根部的null,报错not a funcation等信息，这条查询的链就是原型链
```

## 执行上下文/作用域/闭包

### JS 的执行上下文（执行环境）以及作用域链

> js 中的变量或者函数在运行时都有一个执行上下文关系，也可以称之为执行环境， **执行环境(execution context)**定义了变量或者函数有权访问的其他数据，我们无法通过代码访问这个变量对象，但浏览器在执行时能够访问到
>
> 执行环境中的所有代码执行完以后，执行环境被销毁，保存在其中的变量和函数也随之销毁；(全局执行环境到应用退出时销毁)

> 所谓的**作用域链**，就是当代码在一个执行环境中执行时，会创建变量对象的一个**作用域链**，当代码需要一个变量或者方法时，就会去它的作用域中查找，查找不到会去父级作用域链条查找，直接查找到 windows 对象，作用域链用来指定执行环境有权访问的所有变量和函数的访问顺序；就是执行上下文所形成的访问范围

### 变量对象和活动对象

> js 在编译时，会走一个执行上下文的过程，其中包含了词法作用域，同时创建一个变量对象，其中变量对象包含了所有变量和函数声明，执行过程中，当遇到函数声明时，变量对象会更改为活动对象

### js 的闭包，以及使用的场景，多次使用有什么问题?

> js 中函数可以调用全局变量，但是函数不能调用另一个函数内部的变量，闭包就是为了能够函数调取某个内部变量，从而实现变量缓存

```js
function a() {
  let num = 0;
  return function b() {
    num++;
    return num;
  };
}
let res = a();
console.log(res()); //1
console.log(res()); //2
//闭包中必须返回内部函数，因为第二次调用的时候就是直接调用内部的函数
```

## js 中的 this 指向改变问题，call aply bind

> - 三者都可以通过改变 this 指向，从而达到调用其他方法的目的
> - Call 和 apply 的区别在与传参方式不同，两者都是立即调用
> - call 的用法 被调用方法.call( 要调用的方法.参数 1，参数 2，参数 2，。。。。。 )
> - apply 的用法 被调用方法.call( 要调用的方法.【参数 1，参数 2，参数 2，。。。。。 】 )
> - bind 的用法 被调用方法.bind( 要调用的方法.参数 1，参数 2，参数 2，。。。。。 ) ()
> - 注意 bind 不是一个立即调用方法，必须调用才可以使用

## 异步编程

### 1.JS 异步编程的方式有哪些？

- 回调函数
  实际最常用也最基础的异步编程就是回调函数，但是回调最容易产生回调地狱
- promise
  promise 是为了解决回调地狱问题而诞生，不过 promise 仍然不是最佳的异步解决方法，多个 then 的链式调用也容易混淆
- async
  async 基于 promise 和 genetor 的语法糖，由此声明的函数方法，可以采用 await 来接受异步数据，使其成为同步编程，是目前异步编程中广发推荐的方案

### promise，有哪些方法

- then
- catch
- all
- race
- finaly

### async await 的优势

- 相对于 promise，async 的写法更加优雅
- 可以使用 try catch 更加方便的捕获错误

### requestAnimationFrame 与 setimeout 的区别

- 由于 js 单线程特点，以及 js 的事件循环，settimeout 往往并不能在我们所认为的时间内执行，并且 settieout 执行时如果高于屏幕刷新频率，就会出现卡顿情况
- 相对于 settimeout，requestAnimationFrame 是根据屏幕实际的刷新频率来更新，而且很多浏览器在切入后台,或离开页面时，为了达到省电和节省内存的目的，会暂停 requestAnimationFrame 的运行

## 垃圾回收和内存泄露

### 浏览器 是如何进行垃圾回收的

1. 垃圾回收

   - JS 在代码运行时，会给哪些变量分配一定的内存空间，当这些变量不再参与运行时就会被收回，这就是浏览器的垃圾回收
   - JS 存在全局变量和局部变量，当页面卸载时，全局变量就会被回收，对于局部变量而言，当函数方法运行结束，并且不再参与其他运行时就会被回收

2. 垃圾回收的方式
   我们已经了解了垃圾回收的大致概念，那么接下来探索浏览器到底是以什么来确定某个变量需要被垃圾回收呢

- 标记清除
  这种回收方式简单来讲，就是当某个变量被使用后，标记为已使用，当变量不再被使用时，标记为可回收
- 引用计数
  这种回收方式与上述大概类似，都是对使用的变量进行一定的标记，使用完毕后再次进行标记，然后根据特定的标记进行清除回收

### 什么情况下会造成内存泄漏？

要了解什么情况下会造成内存泄漏，需要先理解为什么会有无法进行垃圾回收的变量，根据上面垃圾回收的知识，我们知道，如果变量持续在内存中被引用就会造成无法回收的状况，那么回答内存泄漏这个问题，实际就是回收什么情况下无法进行垃圾回收的问题

- 全局未声明，但是被引用的变量
  此类变量会挂载到 windows 全局变量上，只要页面不卸载，变量就不会被回收
- 计时器
  计时器能够让我们在理想的时间内做特定的事情，不过如果计时器不被清除，就会造成内存泄漏问题，因此一定程度上建议使用 requeangmation 来代替计时器
- 闭包
  由于闭包中的变量始终被外层函数所引用，因此大量的使用闭包就会造成内存泄漏问题

### js 的垃圾回收机制以及如何防止内存泄露

## EvenLoop 事件循环/宏任务和微任务

### js 的 setimout 为何时间不准确

> 了解了上面的 js 事件循环机制，其实这个问题就会迎刃而解，对于 js 异步代码，分为宏任务和微任务，由于 setimout 属于宏任务，因此在执行前当存在于很多微任务时候，时间就会不准确

> 任何语言都会经历分配内存，使用内存，释放内存的过程
>
> js 中创建变量或者函数时候，会为这个变量分配一定的系统内存，当变量不再使用时，会自动释放内存，何时被释放，大多浏览器采用的标记处理，这个释放的过程便是 js 的垃圾回收机制
>
> 所谓的内存泄露，即是一个变量持续存在于内存中，或者说持续被使用，使得 js 无法判断让其释放，这样就造成了内存泄露
>
> 常见的内存泄露有定时器，死循环等

### js 的事件循环机制

> 首先需要明确的是 js 是单线程运行的，也就是每次只能一个线程
>
> 再次我们将 js 中运行的代码分为同步代码和异步代码
>
> - 同步代码即是按照代码顺序可以正常执行，没有 ajax 回掉函数
> - 异步代码则是有回调，或者有延时的代码
> - js 的运行机制是先运行同步代码，遇到异步代码时，会将其注册，并放入执行栈中，将其加入消息队列，按照先进先出的原则，当一个函数中同步代码运行完毕后，js 会从消息队列中取出一个消息，执行事件循环，所谓的事件循环就是将异步代码分为宏任务和微任务，首先会去执行微任务，当所有的微任务执行完毕后，会再去寻找新的宏任务，进行执行，执行完毕，再去执行这一上下文中的微任务，如此循环
> - 常见的宏任务有 setimeout setindver
> - 常见的微任务有 promise procsss.nextick

参考文章 https://juejin.cn/post/6844903638238756878#heading-8

## 作用域

> js 代码在进行编译时，浏览器会根据定义变量或者函数的标识符确定各自执行的执行范围，并且形成 AST 语法树 ES5:vae ES6:let cost

## 数组乱序（进阶）

## js 中的 forEach 和 map 的区别

> 两个都会遍历原数组，对数组中的每个值进行操作
>
> - forEach 如果对原数组进行操作，数组的值为基本数据类型时，需要写入第一个参数进行映射

```js
//基本数据类型
let arr = [1, 2, 3, 4, 5];
arr.forEach((item, index, arrTemp) => {
  arrTemp[index] = item * 2;
});
console.log(arr); // [2, 4, 6, 8, 10]

//引用数据类型
let arr = [{ a: 1 }, { a: 10 }, { a: 5 }];
arr.forEach((item, index) => {
  item.a = item.a * 10;
});
console.log(arr); //0: {a: 10} 1: {a: 100}2: {a: 50}
```

- map 会返回一个新的数组，操作时需要返回被操作的值

- ```js
  let arr = [{ a: 1 }, { a: 10 }, { a: 5 }];
  let newArr = arr.map((item) => item.a * 2);
  console.log(newArr); //[2, 20, 10]
  ```

### proxy 可实现什么功能

vue3 的底层就是采用了 proxy 来对数据实现响应式，究其原因在于 proxy 能够更能全面的监听到代理数据的变化

## 对象拷贝

> 前端常常在处理数据时，需要拷贝一份，对于单层对象可实现 es6 扩展运算进行拷贝，多层对象可使用 json.parse（json.stringfy（待拷贝对象））实现，不过这种方法也有一个弊端，当对象中某个键对应的值为 uniderfinged 时，将不会被拷贝，同时对于函数方法也不会被拷贝，业界处理方式为引入 lodash 库进行—deepclone 深度克隆

## JS 高阶函数如何使用
