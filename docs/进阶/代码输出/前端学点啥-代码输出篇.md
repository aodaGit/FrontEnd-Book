# 代码输出

## 一,考察点:异步和 JS 事件循环

### 1.promise 只有 resolve 后，才会执行 then

```ts
const promise = new Promise((resolve, reject) => {
  console.log(1);
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
// 输出结果 1 2 4  promise没有relove，因此3无法执行
```

### 2.promise 必须等到 relove 掉后，即使有微任务在先，才可以进入 then 的回调

```ts
const promise = new Promise((resolve, reject) => {
  console.log(1);
  setTimeout(() => {
    console.log("timerStart");
    resolve("success");
    console.log("timerEnd");
  }, 0);
  console.log(2);
});
promise.then((res) => {
  console.log(res);
});
console.log(4);
// 输出结果  1  2   4   timerStart  timerEnd success
// ● 首先遇到Promise构造函数，会先执行里面的内容，打印1；
// ● 遇到定时器steTimeout，它是一个宏任务，放入宏任务队列；
// ● 继续向下执行，打印出2；
// ● 由于Promise的状态此时还是pending，所以promise.then先不执行；
// ● 继续执行下面的同步任务，打印出4；
// ● 此时微任务队列没有任务，继续执行下一轮宏任务，执行steTimeout；
// ● 首先执行timerStart，然后遇到了resolve，将promise的状态改为resolved且保存结果并将之前的promise.then推入微任务队列，再执行timerEnd；
// ● 执行完这个宏任务，就去执行微任务promise.then，打印出resolve的结果。
```

### 3.promise 的状态是不可逆的，当 promise 被 resolve 后，后续的 resolove 和 reject 都不会再去执行

```ts
const promise = new Promise((resolve, reject) => {
  resolve("success1");
  reject("error");
  resolve("success2");
});
promise
  .then((res) => {
    console.log("then:", res);
  })
  .catch((err) => {
    console.log("catch:", err);
  });
// 输出结果   then：success1
// 这个题目考察的就是Promise的状态在发生变化之后，就不会再发生变化。开始状态由pending变为resolve，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。
```

### 4.promise 的 then 支持链式调用，后一个 then 便是前一个 then 的返回值

```ts
Promise.resolve(1)
  .then((res) => {
    console.log(res);
    return 2;
  })
  .catch((err) => {
    return 3;
  })
  .then((res) => {
    console.log(res);
  });
// 输出结果  1  2
```

### 5.promise 的 catch 只能捕获 reject 或者 then 的回调中 threw 的错误，错误只能 threw，return 的错误无法捕获

```ts
Promise.resolve()
  .then(() => {
    return new Error("error!!!");
  })
  .then((res) => {
    console.log("then: ", res);
  })
  .catch((err) => {
    console.log("catch: ", err);
  });
// 输出结果 "then: " "Error: error!!!"
```

### 6.promise 的 then 和 catch 都只能接受回调函数，如果接受的基本数据，则会处理进行数据透传，接受第一个 resolve 的值

```ts
Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log);
// 输出结果 1
```

### 6.promise 的 then 接受两个参数，第一个成功的回调，第二个为错误的回调，当 then 的第二个处理了错误后，catch 就不再运行

```ts
Promise.reject("err!!!")
  .then(
    (res) => {
      console.log("success", res);
    },
    (err) => {
      console.log("error", err);
    }
  )
  .catch((err) => {
    console.log("catch", err);
  });
// 输出结果 error err!!!
// 实际开发中，我们建议在then中处理成功回调，在catch中捕获错误，不建议将then的第二个参数作为错误处理
```

## 二,this

## 三,作用域和变量提升，闭包

## 四,原型和继承
