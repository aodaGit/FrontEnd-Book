# 前端工程化

> 什么是前端工程化呢？思考一个问题，所谓的工程化就是规范化，自动化，从简化，如果能够将一个很复杂的事情，根据它经过的过程，制定一定的规范，简化它的办事流程，并且形成一套约定，那么这就形成了工程化

> 根据上面的解释，我们再来看前端工程化，从编写前端代码到部署上线，我们一共拆分为 四 个主要过程，开发，构建，部署，运维接下来，我们从这 3 个过程来看下，有哪些可以纳入工程化的思考

## 一,开发

### 架构设计和技术选型

> 截止 2022 年，前端的主要技术其实已经 3 分天下，主流的三大框架已经占领了主要的市场，那么在实际开发中，我们应该如何做适合自己团队的架构设计和技术选型呢？
> 思考两个点

1:团队成员的主要技术栈
2:未来项目会发展的方向

结合我自己所在的团队做过的一次技术选型来讲，我所在的团队为美企跨境电商团队，团队主要负责卖家服务维护，早期并不注重 B 端客户体验，近年来随着竞争增强，开始重视起来，当前前端主要的技术栈为 Angular，CTO 要求领导尽快完成系统的重构，但是招聘了一年多，始终没有合适的 Angular 技术人选，简历投递很少，后来我们开始讨论，目前的系统已经非常臃肿，既然开始重构，要为未来的发展做一些规范，也要做一些未来的技术铺垫，我们查询了当前流行的大型中后台解决方案，考虑使用微前端的方式，将前端模块拆分，已迁移的模块继续采用 angular 维护，新的模块采用了 react，选择 react 的原因是公司内部有相对成熟的其他团队在使用 react，而且团队成员也有较多写 react 的经验。

敲定了大概架构方向后，我们最终确定了相对应的技术栈，采用阿里的 qiankun 做微前端框架，主要技术为 react，UI 库便是阿里的 antd

### 目录规范

> 对于目录规范，不同的团队有不同的要求，我们需要始终明白一点，没有完美的工程化，只有适合自己团队的工程化。

> 结合我上面团队的工程化，继续来说目录规范，我们当前的中后台业务相对来说非常庞大，几乎每一个模块都对应着非常多的代码量，因此，区分公共模块和具体的业务模块就非常的重要。

> 我们的做法是 src 下设立 common 文件夹，其中包含公共的 components，utils，ahooks，store 等等，src 下的 pages 为具体的业务模块，每一个模块下又有属于自己模块的 components，utils 等等，由此可以非常完美的抽离公共部分，同时达到最大程度的公用代码

### 开发规范

> 对于开发规范，业界已经有一些公认的最佳实践，我们团队采用了爱彼迎的 js 和 style 开发规范，并集成到了 eslit 和 stylelint 中

```ts
// eslint 配置
module.exports = {
  parser: "@typescript-eslint/parser",
  extends: [
    "plugin:@typescript-eslint/recommended",
    "plugin:import/recommended",
    "plugin:react/recommended",
    "airbnb-typescript",
    "prettier",
  ],
  plugins: ["react", "@typescript-eslint", "react-hooks"],
  env: {
    browser: true,
    node: true,
  },
  settings: {
    react: {
      pragma: "React",
      version: "detect",
    },
  },
  parserOptions: {
    ecmaVersion: 2019,
    sourceType: "module",
    ecmaFeatures: {
      jsx: true,
    },
    project: ["./tsconfig.json"],
  },

  rules: {
    "no-var": "error",
    "@typescript-eslint/no-explicit-any": "off",
    "@typescript-eslint/explicit-module-boundary-types": "off",
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn",
    "react/prop-types": "off",
    "react/jsx-filename-extension": "off",
    "@typescript-eslint/no-unused-vars": ["warn"],
    "import/extensions": [
      "error",
      "ignorePackages",
      {
        js: "never",
        jsx: "never",
        ts: "never",
        tsx: "never",
      },
    ],
  },
};
```

```ts
// stylelint 配置
module.exports = {
  extends: [
    "stylelint-config-standard-scss",
    "stylelint-config-rational-order",
  ],
  customSyntax: "postcss-scss",
  plugins: ["stylelint-scss"],
  rules: {
    indentation: 2,
    "no-missing-end-of-source-newline": null,
    "max-nesting-depth": 3,
    "selector-max-compound-selectors": 3,
    "at-rule-no-unknown": null,
    "scss/at-rule-no-unknown": true,
    // 拒绝文件命名使用kebab-case规则！！！！
    "selector-class-pattern": null,
    "string-quotes": "single",
    "at-rule-empty-line-before": null,
    "at-rule-no-unknown": null,
    "at-rule-name-case": "lower",
    "length-zero-no-unit": true,
    "shorthand-property-no-redundant-values": true,
    "number-leading-zero": "never",
    "declaration-block-no-duplicate-properties": true,
    "no-descending-specificity": true,
    "selector-max-id": 0,
    "max-nesting-depth": 3,
    indentation: [
      2,
      {
        severity: "warning",
      },
    ],
  },
};
```

### 提交规范

> 代码提交规范实际上是从 angular 框架中借鉴的，angular 有非常严格的代码 commit 规范

> 思考一个问题，如果我们的用户正在使用我们产品的时候遇到了一些问题，我们需要去修复，在我们排查最佳提交了什么代码的时候，发现 commit message 全是相同的，这会让人非常头大，如果我们每一次的提交都有一些标记当前提交的代码属于什么类型，做了什么样的事情，那么就非常有利于我们后期的回溯和查找

> 我们可以对提交的 message 进行格式校验，不符合的时候需要查看具体的规则

> 如何来实现呢，git 提交时有一些提交的钩子函数，如果我们在 git 的 commit 钩子中校验我们的提交，那么就可以达到这样的效果

我们团队的提交规范

```ts
// packagejson中配置husky
 "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "node script/verify-commit.js"
    }
  },


// script中的校验
/**项目commit格式校验 */
const msgPath = process.env.HUSKY_GIT_PARAMS
const commitMsg = require('fs').readFileSync(msgPath, 'utf-8').trim()
const commitREG =
  /^(feat|fix|docs|style|refactor|perf|test|workflow|build|ci|chore|release|workflow)/g
// feat: 新功能、新特性
// fix: 修改 bug
// perf: 更改代码，以提高性能
// refactor: 代码重构（重构，在不影响代码内部行为、功能下的代码修改）
// docs: 文档修改
// style: 代码格式修改, 注意不是 css 修改（例如分号修改）
// test: 测试用例新增、修改
// revert: 恢复上一次提交
// ci: 持续集成相关文件修改
// chore: 其他修改（不在上述类型中的修改）
// release: 发布新版本
// workflow: 工作流相关文件修改
if (!commitREG.test(commitMsg)) {
  console.error(`
        commit 消息格式错误，请到根目录script/verify-commit 下查看具体提交格式。
    `)
  process.exit(1)
}

```

### UI 交互规范

> 很多小伙伴不明白，前端工程化为何需要 UI 规范，实际上很简单，因此前端实际上就是个页面仔，既然画页面，避免不了 UI 交互，UI 又是由 UI 设计师设计，因此这个 UI 规范需要前端和 UI 公共制定。

> 那么我们需要制定什么样的规范呢？

> 从我们团队的经验说起，我们知道前端画的页面大概可以 HTML，CSS，JS，其中前两者是 UI 会涉及到的。

> HTML:对于系统中常见的 UI 组件，我们建议 UI 设计师尽量统一化，具体设计时可以参考我们所使用的 UI 框架，UI 框架不存在的，尽量保持全局的设计风格统一，如弹出框的确认和取消按钮的左右位置等等，尽量保持一致

> CSS:一个完成的系统，肯定存在统一的色码表，我们可以要求 UI 制定一套统一的色码表，前端可以生成一个统一的 less 或者 scss 文件，以变量形式表示，这样有助于后续的维护，对于元素 box 之间的间隙也制定一定的规则，如我们团队制定的上下间隙为 8px

### 分支规范

> 合理的分支规范有助于后续更长久的维护和回溯。

> 对于日常开发，我们会有这样几类需求，1:新增功能 2:修复部分 bug 3 仅供灰度测试的 pre 分支，由此可以根据这几类需求，在具体开发时，基于主干，生成这样的分支，测试上线完毕后，再做删除处理，另外，为了保持多个版本的共存，对于大的版本更新，及时打 tig 标记，以方便后续回溯

## 二,构建

### 打包优化

> 关于 webpack 的打包优化，可到性能优化查看，具体包含代码分割，代码压缩，多线程打包，打包缓存，指定文件打包

### CDN 优化

> CDN 可以简单理解为对网络请求的一种资源分配优化

> 目前的云服务商都提供了 CDN 服务，可对我们的静态资源和代码做到最优距离的加载

> 具体的使用可结合具体的云服务商开启。

### 网络请求优化

1. 开启 http2 甚至 http3 的使用
2. 制定详细的浏览器缓存方案

## 三,部署

### 自动化部署

结合 gitlab 的 webhook 钩子，采用 jekins 等自动推送代码到 docker 镜像中

## 四,运维

### 监控

> 自造或者第三方
> 第三方可使用 sentry

### 前端攻击类型，如何防止攻击

> 前端攻击主要分为两种 CSRF 和 XSS
>
> - CSRF 简单说就是攻击者拿着你的账号信息，向服务器获取数据，然鹅服务器还没办法去识别这个恶人。此类型的攻击从两个角度去降低攻击度，1:增加向后端请求的复杂度。2:增加对用户的信息校验
>   - 涉及登录注册等接口，使用 post，而不是 get 请求
>   - 响应数据中设置 response.setHeader( "Set-Cookie", "cookiename=cookievalue;HttpOnly”);,cookie 只能通过请求去获取，不允许通过 js 脚本等获取 cookie 信息
>   - 设置 token 验证，用户登录后获取一个 session 中的 id 作为 token，请求接口中请求头携带 token

### 脚手架

### 包管理

[前端如何发布 NPM 包](./制作NPM包/前端学点啥-制作NPM包.md)

### doucker 镜像

#### 如何将自己的项目部署在 doucker 中

https://zhuanlan.zhihu.com/p/84894157

### 前端项目如何部署

> 手动部署 前端代码 > 打包（yarn build）> 上传到 linux 系统指定项目文件夹目录下 > 配置 linux 系统中 ngix config 文件
> 自动部署 前端代码 > 推送到远端分支 > CICD 触发自动构建 > 自动上传文件到指定目录
> doucker 容器如何进行配置

## Serverless 是什么？

> 简单来说，就是前端只需要关注自己的编码，不需要关心系统部署，运维，负载均衡等，这些繁杂事，全都交给云服务器服务商
