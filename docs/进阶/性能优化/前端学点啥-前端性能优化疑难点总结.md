# 前端性能优化

## 从页面输入 url 到渲染的全过程？（详细版）

1. 分析性能
   > 使用谷歌的开源分析 https://pagespeed.web.dev/

网络请求===资源加载===页面渲染

网络层优化 http 请求优化 浏览器请求资源 cdn 资源优化

资源加载
资源加载体积

图像 大图压缩 小图 base64 CDN 中的 webp 资源支持

JS
拆分大的框架库，采用 ejs 写法 在生产环境使用公共 CDN
代码分割
按需加载
摇树优化
gzip 压缩

## 性能分析

### 构建完毕分析优化

### 打包分析

## 图像

小图标打包成 base64 二进制流 降低体积
CDN 服务器打开 webp 图像格式支持
图标采用字体库 react-icons

## css 头部引入

webpack 集成

## 缓存

CDN 缓存
http 请求缓存 浏览器缓存 减少请求握手次数

## 网络请求

多路复用
头部压缩

## js 脚本

body

1. 按需引入
2. 代码摇树优化
3. 代码分割
4. 打包缓存
5. 多线程打包 仅针对 JS 开启多线程打包
6. gzip 压缩
7. 公共依赖生产环境存放 公共 CDN

## 视觉优化

异步请求 loading
图像懒加载
定时任务的 requestAnimition

### 从 URL 到页面展示经历的过程

> 要回答这个面试必考问题，我们首先需要了解我们的页面所展示的内容究竟是如何存储在网络世界中的，只有这样，我们才能全面的回答这个问题

> 平时我们所能看到的网页上的任何东西，都是储存在某一台服务器上，为了便于识别管理和查询，每台服务器都有一个编号，这个编号就是网络世界里的 IP 地址，当我们输入 URL 时，就是为了查询具体的 URL 所对应的服务器 IP 地址。

> - 第一步：当我们输入搜索关键字的时候，浏览器无法通过关键字直接获取到 IP 地址，需要先通过 DNS 去解析我们输入的内容，从而找到文件所在的 ip 地址，这一过程就是 DNS 解析，这一过程就会存在<u>**DNS 缓存**</u>，浏览器会保存我们第一次的搜索内容和对应的 ip，当第二次搜索同样的内容时，就不会直接去服务器获取 ip，会通过 DNS 缓存拿起 IP 地址，具体是第一次拿到 IP 地址后，存储在硬盘缓存中，第三次再次刷新请求时，便直接会从内存中拿取对应的 IP 地址
> - 第二步：第一步拿到 ip 地址后，浏览器会和服务器发起会话请求，当我们需要的内容有 CDN 分发时，首次请求会通过 CDN 服务器向主服务器发起请求，获取数据，第二次时，浏览器会通过 CDN 服务器缓存的数据拿取，这一过程就是**<u>CDN 缓存</u>**
> - 第三步：第二步拿到资源后，浏览器会根据 ip 地址和请求参数，去获取数据，这时如果服务器设置了强缓存，服务器将会在首次加载资源的时候，返回 expire 或者 catch-thre ，两者可以同时设置，这样，浏览器在下次请求资源资源时，会先去查找缓存的内容，当缓存不存在的时候，才会去服务器获取相关资源
>
> 浏览器中 from memory catche 和 from disk cache 的区别
>
> - from memory catche 是指从内存中获取缓存的资源，当页面关闭后，资源也会随之释放
> - from disk cache 是指从磁盘中获取缓存的资源，页面关闭后，资源仍然存在，状态码为 304，即服务器资源没有更新，加载本地资源

> - 性能优化主要可从两个方面出发下手，资源加载的体积和网络请求相关资源的速度
> - 性能分析 webpack-bundle-analyzer ，此插件可分析加载的第三方资源所占的比例
> - 资源体积：
>
>   - ngix 反向代理中设置 gzip 代码压缩
>   - 图片体积 静态图片资源进行压缩，网站https://tinyjpg.com/
>   - treeShaking 未使用代码抖落优化，webpack4 中默认支持代码摇树优化
>
> - 加载速度
>   - 组件懒加载 对于未使用的组件，懒加载，提交首屏速度
>   - 缓存 对于静态资源进行缓存，提高服务器响应时间
>   - 雪碧图 减少图片请求次数
>   - 代码分割 将较大的第三方模块进行分割下载，提高加载速度
>   - 多线程打包 webpack 内置的 happyPack

https://juejin.cn/post/6904517485349830670

https://juejin.cn/post/6844904071736852487#heading-20 webpack 打包性能优化
