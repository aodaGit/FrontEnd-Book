# JS

## 作用域

> js 代码在进行编译时，浏览器会根据定义变量或者函数的标识符确定各自执行的执行范围，并且形成 AST 语法树 ES5:vae ES6:let cost

## 数组乱序（进阶）

## sysbol 的使用场景

> sysbol 为 es6 新的数据类型，通过 sysbol（）方法可以得到一个独一无二的值
>
> 根据此特征，我们可以的主要使用场景可以为独一无二的变量值的设定

## js 的执行上下文（执行环境）以及作用域链

> js 中的变量或者函数在运行时都有一个执行上下文关系，也可以称之为执行环境， **执行环境(execution context)**定义了变量或者函数有权访问的其他数据，我们无法通过代码访问这个变量对象，但浏览器在执行时能够访问到
>
> 执行环境中的所有代码执行完以后，执行环境被销毁，保存在其中的变量和函数也随之销毁；(全局执行环境到应用退出时销毁)

> 所谓的**作用域链**，就是当代码在一个执行环境中执行时，会创建变量对象的一个**作用域链**，作用域链用来指定执行环境有权访问的所有变量和函数的访问顺序；就是执行上下文所形成的访问范围

## 变量对象和活动对象

> js 在编译时，会走一个执行上下文的过程，其中包含了词法作用域，同时创建一个变量对象，其中变量对象包含了所有变量和函数声明，执行过程中，当遇到函数声明时，变量对象会更改为活动对象

## var let const 的区别

> 三者都是 js 中用来解析变量的标识符
>
> > var 声明的变量，会被提升到作用域最前端，也就是即使变量在执行顺序后，变量也会被提升到最前面
> >
> > Let 声明的变量会形成一个快级作用域，也就是只可以在声明后执行，并且不可重复声明
> >
> > Const 声明的变量也会形成一个快级作用域，区别在于 const 声明的变量会形成常量，不可再次进行声明和赋值（基本不可，引用可增加键值），如果让一个对象不可更改，不可增加键值，可用 object.fressze（）将对象进行冻结

## js 数据类型

> js 包含七种类型。null underfined string number boolber object Sybil

## 基础数据

- 基础数据类型包括 字符串 数字 布尔值 null undefinded
- 基础数据类型存放在栈中
- null 属于 object 类型 object 下有数组 对象 函数三个子类型
- 数组可以直接通过 arr【索引】取值 但是，对于不存在的索引，数组的值将会是 underfine
- 字符串前添加+号，可以转换为数字
- 字符串与数字前加！！可以转换为布尔值

## 引用数据类型

- 引用数据类型包括： 数组 对象
- 由于引用数据类型的空间是不确定的，因此引用数据在存放数据时，会将指针存放在栈中，值存放在堆中

## js 如何准确无误的判断数据类型

> type of 可准确判断数字，字符串，布尔值，undefinde 数组，对象，null 会显示位 object，函数会显示会 function
>
> Instace of 适合判断 object 对象的值
>
> constract
>
> 通用的方法 采用 object.prototype。toString.call 会返回一个【object 数据类型】从而来判断数据类型

## js 中的 this 指向改变问题，call aply bind

> - 三者都可以通过改变 this 指向，从而达到调用其他方法的目的
> - Call 和 apply 的区别在与传参方式不同，两者都是立即调用
> - call 的用法 被调用方法.call( 要调用的方法.参数 1，参数 2，参数 2，。。。。。 )
> - apply 的用法 被调用方法.call( 要调用的方法.【参数 1，参数 2，参数 2，。。。。。 】 )
> - bind 的用法 被调用方法.bind( 要调用的方法.参数 1，参数 2，参数 2，。。。。。 ) ()
> - 注意 bind 不是一个立即调用方法，必须调用才可以使用

## js 的垃圾回收机制以及如何防止内存泄露

> 任何语言都会经历分配内存，使用内存，释放内存的过程
>
> js 中创建变量或者函数时候，会为这个变量分配一定的系统内存，当变量不再使用时，会自动释放内存，何时被释放，大多浏览器采用的标记处理，这个释放的过程便是 js 的垃圾回收机制
>
> 所谓的内存泄露，即是一个变量持续存在于内存中，或者说持续被使用，使得 js 无法判断让其释放，这样就造成了内存泄露
>
> 常见的内存泄露有定时器，死循环等

## js 的闭包，以及使用的场景，多次使用有什么问题?

> js 中函数可以调用全局变量，但是函数不能调用另一个函数内部的变量，闭包就是为了能够函数调取某个内部变量，从而实现变量缓存

```js
function a() {
  let num = 0;
  return function b() {
    num++;
    return num;
  };
}
let res = a();
console.log(res()); //1
console.log(res()); //2
//闭包中必须返回内部函数，因为第二次调用的时候就是直接调用内部的函数
```

## 箭头函数与普通函数的区别

> 语法更为简洁。 ()=>{}
>
> 箭头函数没有 protype
>
> 箭头函数不可以使用 this，箭头函数的 this 指向的是定义时外向的第一个对象
>
> 箭头函数不能获取 argments，可以使用剩余参数实现

## js 中的继承

> js 中的继承可以分为原型链继承，类对象继承，混合试继承

## 异步编程 promise

-

## this 指向

## 对象原型

## 对象拷贝

> 前端常常在处理数据时，需要拷贝一份，对于单层对象可实现 es6 扩展运算进行拷贝，多层对象可使用 json.parse（json.stringfy（待拷贝对象））实现，不过这种方法也有一个弊端，当对象中某个键对应的值为 uniderfinged 时，将不会被拷贝，同时对于函数方法也不会被拷贝，业界处理方式为引入 lodash 库进行—deepclone 深度克隆

## js 的事件循环机制

> 首先需要明确的是 js 是单线程运行的，也就是每次只能一个线程
>
> 再次我们将 js 中运行的代码分为同步代码和异步代码
>
> - 同步代码即是按照代码顺序可以正常执行，没有 ajax 回掉函数
> - 异步代码则是有回调，或者有延时的代码
> - js 的运行机制是先运行同步代码，遇到异步代码时，会将其注册，并放入执行栈中，将其加入消息队列，按照先进先出的原则，当一个函数中同步代码运行完毕后，js 会从消息队列中取出一个消息，执行事件循环，所谓的事件循环就是将异步代码分为宏任务和微任务，首先会去执行微任务，当所有的微任务执行完毕后，会再去寻找新的宏任务，进行执行，执行完毕，再去执行这一上下文中的微任务，如此循环
> - 常见的宏任务有 setimeout setindver
> - 常见的微任务有 promise procsss.nextick

参考文章 https://juejin.cn/post/6844903638238756878#heading-8

## js 的 setimout 为何时间不准确

> 了解了上面的 js 事件循环机制，其实这个问题就会迎刃而解，对于 js 异步代码，分为宏任务和微任务，由于 setimout 属于宏任务，因此在执行前当存在于很多微任务时候，时间就会不准确

## js 中 null 和 underfined 的区别

> 简而言之，这是一个历史遗留问题，null 和 uniderfinde 都可以表示不存在的值，只是 null 表示丢失的对象，underdined 声明了，但是未赋值时
>
> 检测类型中 typeof null 为对象 typeof underdinded 为 underfinde
