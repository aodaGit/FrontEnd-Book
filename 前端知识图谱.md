# 前端知识图谱

## 初级

### 前端基础

### 研发工具

### HTML

#### 前端 seo，单页面下如何去做 seo

> SEO 指的是搜索引擎网站对网站的搜索比重
>
> 单页面（前端三大框架全部为单页面）在百度中不予收录
>
> 目前单页面所做的 seo 处理有两种优化方案
>
> - 首页采用服务器渲染
> - 服务器判断访问的是浏览器还是爬虫服务器，如果是爬虫，交给 prerender 处理，prerender 是谷歌和必应推荐的做 seo 优化的预呈现插件
> - 进行转发代理，代理处理后，返回给爬虫服务器 seo 的相关信息
> - 知乎案列 https://zhuanlan.zhihu.com/p/36241703

#### html 头部的 doctype 的作用

> 当页面添加这个头部时，意在告诉浏览器，这是标准模式解析
>
> 浏览器可以加载<u>**标准模式**</u>和<u>**怪异模式**</u>
>
> 两者的区别在于两者对于宽度 width 的定义不同，标准模式下，元素在页面中所占的宽度为 padding+width+margin+border
>
> 怪异模式下 width=padding+border. 实际上页面所占的距离只有 width+margin

#### div+css 和 table 布局的特点，各自的优点

> div+css 遵循结构和表现分离原则，通常更换 css 样式就可以更换整个网站风格
>
> div+css 可以边加载边显示，相对于表格的完全加载完才可以显示而言，加载速度更快
>
> div+css 可以通过布局来实现部分数据的较快加载，典型的如圣杯布局
>
> 相对而言，代码结构清晰，后期更容易维护

#### img 的 alt 和 title 有什么异同

> title 是每一个元素都共有的属性，可以设置 title 来提示元素设置的特殊化信息
>
> alt 为图片特有的属性，当图片资源加载异常时，会用设置的 alt 信息来替代
>
> seo 中设置图片 alt 的属性会增强 seo

#### 优雅降级和渐进增强

> 可以理解为程序设计的两种模式，优雅降级主要是在高级运行中向下兼容，如 vue react 的 babel 转义
>
> 渐进增强为向上逐渐高级的写法，如 jquery 中使用 vue

#### 为何要使用多个域名来保存网站资料，cdn 是什么

> cdn 是指针对某一资源，加载离用户最近的服务器资源网络
>
> 可以减少主服务器的压力，增加并发量，防止不必要的数据丢失等

#### cookie localstorage sessionStorage session 的区别

> 区别 前三者均存在客户端，也就是浏览器上，session 存放在服务器上

##### cookie

当用户第一次向某个服务器发起请求时，浏览器和服务器就会建立一次对话连接，在服务器端生成一个 session，

同时向浏览器返回 cookis 值，主要保存关于用户登录状态的一些重要信息（账户，密码，停留时间等），其中包含一个 sessionID，cookis 也可以设置生效时长，如不设置，则默认为关闭浏览器失效，之后，当客户端每次向服务器发起请求时，请求头中都会携带 cookis，以让服务器端来验证用户的登录信息，以及相应对应的数据等，由于每次都可以携带 cookis 发起请求，因此客户端限制 cookis 只能携带 4k 的东西，当然为了节省宽带，降低服务器的消耗，cookis 中一般存放一些重要的信息，其他的都存放在 cookis 中

##### localstorage

这是浏览器新支持的存放方式，客户端可以使用 set 和 get 方法，对其进行存取，原则上，loacl 中存储的东西可以永久保存

##### sessionstorag

sessionstorge 存在于页面与页面所建立起的对话，当浏览器关闭的时候，sessionstorage 就会消失

##### session

session 为服务器端存放的数据，主要保存用户的一些基础信息，同时可以对 cookis 的值进行更新

#### h5 的离线缓存

> 参考文章 https://zhuanlan.zhihu.com/p/70883817
>
> 实现原理就是 html 文件中，设置 minfest 属性，浏览器通过 minfest 属性，去解析需要缓存什么内容，从而达到浏览器断网后也可以缓存的效果
>
> 实施步骤
>
> - 设置 html 头
>
>   - ```html
>     <!DOCTYPE html>
>     <html lang="en" manifest="demo.appcache">
>       <head>
>         <meta charset="UTF-8" />
>         <title>demo</title>
>       </head>
>       <body>
>         <img src="img.jpg" height="500" width="900" alt="" />
>         其它内容...
>       </body>
>     </html>
>     ```
>
>     manifest 文件可分为三个部分：
>
>     - CACHE - 在此标题下列出的文件将在首次下载后进行缓存。
>     - NETWORK- 在此标题下列出的文件需要与服务器连接，且不会被缓存。可以使用\*，表示除 CACHE 外的所有其他资源/文件都需要因特网连接。
>     - FALLBACK- 在此标题下列出的文件规定当页面无法访问时的替代页面。
>
> - 检索需要设置缓存的资源
>
>   - ```html
>     CACHE MANIFEST #version 1.0 CACHE： img.jpg NETWORK: * FALLBACK: /demo/
>     /404.html
>     ```
>
> - **操作 window.applicationCache 进行需求实现。**
>
>   - ```js
>     unction handleCacheEvent(e) {
>             对应操作...
>         }
>         function handleCacheError(e) {
>            alert('Error: Cache failed to update!');
>         };
>         //在浏览器为应用缓存查找更新时触发
>         oAppCache.addEventListener('checking', handleCacheEvent, false);
>         //在检查描述文件发现文件无变化时触发
>         oAppCache.addEventListener('noupdate', handleCacheEvent, false);
>         // 在开始下载应用缓存资源时触发
>         oAppCache.addEventListener('downloading', handleCacheEvent, false);
>         //在文件下载应用缓存的过程中持续不断地下载地触发
>         oAppCache.addEventListener('progress', handleCacheEvent, false);
>         //在应用缓存完整可用时触发
>         oAppCache.addEventListener('cached', handleCacheEvent, false);
>         //在页面新的应用缓存下载完毕触发
>         oAppCache.addEventListener('updateready', function(){
>               oAppCache.swapCache();// 更新本地缓存
>               location.reload();    //重新加载页面页面
>             }, false);
>         //在检查更新或下载资源期间发送错误时触发
>         oAppCache.addEventListener('error', handleCacheError, false);
>         //缓存清单不存在时触发
>         oAppCache.addEventListener('obsolete', handleCacheEvent, false);
>     ```
>
> - **在服务器端正确的配置 MIME-type。**
>
>   - 在 tomcat 服务器中的 conf/web.xml 中添加：
>
>     ```html
>     <mime-mapping>
>       <extension>manifest</extension>
>       <mime-type>text/cache-manifest</mime-type>
>     </mime-mapping>
>     ```

#### src 和 href 的区别

> src 英文直译过来就是加载资源的意思，顾名思义就是引入外部链接，一般会使得浏览器停止当前行为，来运行这一加载资源的行为
>
> href 指的是网络资源中的位置，是元素和文档之间的链接关系
>
> 因此，**js 脚步使用 src 来引入时，就不可以放入头部，会导致页面的阻塞加载，这也是为什么推荐 css 样式使用 link 引入的原因**

#### 网页中的使用的图片

> 根据我们使用的使用经验，目前将图片分为三类，**<u>透明图层，不透明图层，动图，矢量图</u>**
>
> 其中透明图层为 png，动图为 gif，不透明为 jpg，jpeg，webp 格式，矢量图为 svg
>
> 目前最优的图片则是 webp，这是由谷歌公司创建的新图片格式，比 jpg 体积更小，显示更为清晰，不过 webp 兼容性不是很好，使用时需要判断当前浏览器是否支持 webp 格式
>
> 常见的压缩图片的网站 tinyPng 谷歌的 Squoosh（无法进行批量转换）

#### 热点地图是什么

### CSS

#### 控制元素显示隐藏的方法，并说明区别

> 主要有两种方式 display 和 visibility
>
> - display
>   - block 可以让元素显示
>   - none 隐藏元素
>   - 当使用了 none 隐藏元素后，节点会从 AST 渲染树中去除，儿子节点和事件会完全被取消，即使儿子元素设置 display：block
> - visibility
>   - Visiberl 显示元素
>   - hidden 隐藏元素
>   - 使用 hidden 隐藏元素后，元素只是在页面看不见，但是依然留在渲染树中，当父节点使用 visiility 隐藏后，子节点会隐藏，但是子节点设置的布局样式依然会发生作用，子节点可以使用 visiblity：viasibel 显示，并且事件可以执行

#### 如何实现瀑布流布局

#### flex 和 grid 布局的区别

> 区别：两者的区别在于侧重点不一致
>
> - flex 侧重于一维布局，即同一方向布局
> - grid 侧重于二维布局，即行和列同时去操作布局，目前业界不使用的理由是兼容性很差，以及一维布局使用不方便，瀑布流布局中可采用 grid 布局

#### 移动端 1px 问题

> 当移动端设置 1px 的时候，实际设置的 1 个物理像素，当手机像素较高时就会出现边框较粗的现象
>
> 解决方案：
>
> - 第一种办法 判断设备的物理像素，根据物理像素对边框值进行缩放处理
>
> ```css
> .foo {
>   /* Output example */
>   .test {
>     border: 1px solid #000;
>     @media (min-resolution: 2dppx) {
>       .test {
>         position: relative;
>         border: none;
>       }
>       .test::before {
>         content: "";
>         position: absolute;
>         left: 0;
>         top: 0;
>         width: 200%;
>         height: 200%;
>         border: 1px solid #000;
>         border-radius: 0px;
>         transform-origin: 0 0;
>         transform: scale(0.5);
>         box-sizing: border-box;
>         pointer-events: none;
>       }
>     }
>     @media (min-resolution: 3dppx) {
>       .test::before {
>         width: 300%;
>         height: 300%;
>         border-radius: 0px;
>         transform: scale(0.33);
>       }
>     }
>   }
> }
> ```
>
> - 第二种办法 直接引入 postcss-1px-border 第三方插件解决

#### css hack

> Css hack 是指，针对不同的浏览器，使用不同版本可以识别的特殊符号，从而实现不同版本浏览器下，加载不同的样式效果

#### 快级和行级元素的区别

> - 快级元素独占一行，padding 和 marging 全部有作用
> - 行内级别，水平方向排列，上下内边距和上下外边距设置无效
> - 两者可以通过 display=block 和 display=inner-block 相互转换

#### 可替换元素与不可替换元素的区别

> 可替换与不可替换元素的区别就在于元素是否直接按照内容显示，如 image 是根据 src 属性引入的文件决定元素大小，为可替换
>
> div span 等为不可替换
>
> 不可替换元素的内外边距上下不会影响布局，这也就是为什么 span 标签设置了 padding 和 margi 上下不会影响布局

#### 什么是空元素

> HTML 中有三类元素，快级 行内，空元素
>
> 其中空元素指的是 html 中不能存在子节点的元素
>
> 常用的空元素有 img input textarea meta 等

#### 元素转换为 inner-block 行内快级后会有什么问题？怎么解决

> 转换为快级行内后，如果代码内的内容换行，会出现间隙，原因是转换为快级行内后，浏览器将换行符也当成了行内的元素内容，基于此，有两种解决合并可以解决此问题
>
> - 设置父元素的字体大小
>   - 父元素 font-size=0，子元素重新设置 font-size 大小，缺点是在谷歌浏览器中，给字体设置了最小值 12px，设置为 0 无法生效，因此需要再次进行处理
> - 设置父元素 letter-spacing
>   - 父元素 letter-spacing=负值，子元素设置 letter-spacing=0

#### 什么是外边距重叠，重叠的效果是什么？

> 外边距重叠是指，当两个元素盒子元素在设置外边距的时候，重合的一端会产生值的合并
>
> - 两个都是正值时，取最大的
> - 两个都是负的时，取绝对值最大的
> - 两个一正一负时，取两个的和

#### css 中水平和垂直重叠可以用什么来实现

> - 垂直方向可以用 line-height，当和 height 一样时，会实现垂直居中效果
> - 水平方向可以用 letter-spaceing，当设置负值时，会将元素重叠

#### px em rem vw vh 单位的区别

> px 是像素单位，pc 端开发中经常使用这个单位
>
> em 是指相对于父亲设置 font-size，而且会根据父亲的字体大小，来调整自己的大小
>
> rem 是指相对于 body 根元素设置 font-size，这样可以实现所有的元素大小根据 body 来改变大小，通常 app 端，使用这一方案，实现不同的手机兼容
>
> vw 和 vh 是视窗宽度和视窗高度，是指在整个设备的视窗中，可以设置不同比例，100vw 和 100vh 将会占满整个屏幕

#### css 预编译器，react 中用什么方案解决更好

> css 预编译器是 css 语法的增强版，可以让原生的 css 实现代码更好的继承复用，采用变量书写 css 等
>
> less 与 sass 都可以实现此类功能
>
> vue 中采用 css 预编译，可以让文件作用于当前 css
>
> react 要实现这样的效果，目前官方推荐 css in js，防止全局污染

#### BFC 快级上下文

> BFC 会形成一个快级渲染盒子，盒子内的布局不会影响盒子外的布局，有点类似于 js 的作用域名
>
> 其中，display=block inner-block position=abroute fied 都会形成 BFC

#### 如果写 css 动画，你认为最小间隔时间是多少？

> 这是一个根据常识去计算某个值的问题
>
> 市面上常见的屏幕分辨率为 60HZ，也就是每秒钟刷新 60 次，所以理论上最小间隔时间应该是 1/60\*1000ms 16.7ms

#### base64 的原理以及缺点

> base64 是将二进制流转换为字符串的形式，可以达到部分加密的作用

### JS

#### 作用域

> js 代码在进行编译时，浏览器会根据定义变量或者函数的标识符确定各自执行的执行范围，并且形成 AST 语法树 ES5:vae ES6:let cost

#### 数组乱序（进阶）

#### sysbol 的使用场景

> sysbol 为 es6 新的数据类型，通过 sysbol（）方法可以得到一个独一无二的值
>
> 根据此特征，我们可以的主要使用场景可以为独一无二的变量值的设定

#### js 的执行上下文（执行环境）以及作用域链

> js 中的变量或者函数在运行时都有一个执行上下文关系，也可以称之为执行环境， **执行环境(execution context)**定义了变量或者函数有权访问的其他数据，我们无法通过代码访问这个变量对象，但浏览器在执行时能够访问到
>
> 执行环境中的所有代码执行完以后，执行环境被销毁，保存在其中的变量和函数也随之销毁；(全局执行环境到应用退出时销毁)

> 所谓的**作用域链**，就是当代码在一个执行环境中执行时，会创建变量对象的一个**作用域链**，作用域链用来指定执行环境有权访问的所有变量和函数的访问顺序；就是执行上下文所形成的访问范围

#### 变量对象和活动对象

> js 在编译时，会走一个执行上下文的过程，其中包含了词法作用域，同时创建一个变量对象，其中变量对象包含了所有变量和函数声明，执行过程中，当遇到函数声明时，变量对象会更改为活动对象

#### var let const 的区别

> 三者都是 js 中用来解析变量的标识符
>
> > var 声明的变量，会被提升到作用域最前端，也就是即使变量在执行顺序后，变量也会被提升到最前面
> >
> > Let 声明的变量会形成一个快级作用域，也就是只可以在声明后执行，并且不可重复声明
> >
> > Const 声明的变量也会形成一个快级作用域，区别在于 const 声明的变量会形成常量，不可再次进行声明和赋值（基本不可，引用可增加键值），如果让一个对象不可更改，不可增加键值，可用 object.fressze（）将对象进行冻结

#### js 数据类型

> js 包含七种类型。null underfined string number boolber object Sybil

##### 基础数据

- 基础数据类型包括 字符串 数字 布尔值 null undefinded
- 基础数据类型存放在栈中
- null 属于 object 类型 object 下有数组 对象 函数三个子类型
- 数组可以直接通过 arr【索引】取值 但是，对于不存在的索引，数组的值将会是 underfine
- 字符串前添加+号，可以转换为数字
- 字符串与数字前加！！可以转换为布尔值

##### 引用数据类型

- 引用数据类型包括： 数组 对象
- 由于引用数据类型的空间是不确定的，因此引用数据在存放数据时，会将指针存放在栈中，值存放在堆中

##### js 如何准确无误的判断数据类型

> type of 可准确判断数字，字符串，布尔值，undefinde 数组，对象，null 会显示位 object，函数会显示会 function
>
> Instace of 适合判断 object 对象的值
>
> constract
>
> 通用的方法 采用 object.prototype。toString.call 会返回一个【object 数据类型】从而来判断数据类型

#### js 中的 this 指向改变问题，call aply bind

> - 三者都可以通过改变 this 指向，从而达到调用其他方法的目的
> - Call 和 apply 的区别在与传参方式不同，两者都是立即调用
> - call 的用法 被调用方法.call( 要调用的方法.参数 1，参数 2，参数 2，。。。。。 )
> - apply 的用法 被调用方法.call( 要调用的方法.【参数 1，参数 2，参数 2，。。。。。 】 )
> - bind 的用法 被调用方法.bind( 要调用的方法.参数 1，参数 2，参数 2，。。。。。 ) ()
> - 注意 bind 不是一个立即调用方法，必须调用才可以使用

#### js 的垃圾回收机制以及如何防止内存泄露

> 任何语言都会经历分配内存，使用内存，释放内存的过程
>
> js 中创建变量或者函数时候，会为这个变量分配一定的系统内存，当变量不再使用时，会自动释放内存，何时被释放，大多浏览器采用的标记处理，这个释放的过程便是 js 的垃圾回收机制
>
> 所谓的内存泄露，即是一个变量持续存在于内存中，或者说持续被使用，使得 js 无法判断让其释放，这样就造成了内存泄露
>
> 常见的内存泄露有定时器，死循环等

#### js 的闭包，以及使用的场景，多次使用有什么问题?

> js 中函数可以调用全局变量，但是函数不能调用另一个函数内部的变量，闭包就是为了能够函数调取某个内部变量，从而实现变量缓存

```js
function a() {
  let num = 0;
  return function b() {
    num++;
    return num;
  };
}
let res = a();
console.log(res()); //1
console.log(res()); //2
//闭包中必须返回内部函数，因为第二次调用的时候就是直接调用内部的函数
```

#### 箭头函数与普通函数的区别

> 语法更为简洁。 ()=>{}
>
> 箭头函数没有 protype
>
> 箭头函数不可以使用 this，箭头函数的 this 指向的是定义时外向的第一个对象
>
> 箭头函数不能获取 argments，可以使用剩余参数实现

#### js 中的继承

> js 中的继承可以分为原型链继承，类对象继承，混合试继承

#### 异步编程 promise

-

#### this 指向

#### 对象原型

#### 对象拷贝

> 前端常常在处理数据时，需要拷贝一份，对于单层对象可实现 es6 扩展运算进行拷贝，多层对象可使用 json.parse（json.stringfy（待拷贝对象））实现，不过这种方法也有一个弊端，当对象中某个键对应的值为 uniderfinged 时，将不会被拷贝，同时对于函数方法也不会被拷贝，业界处理方式为引入 lodash 库进行—deepclone 深度克隆

#### js 的事件循环机制

> 首先需要明确的是 js 是单线程运行的，也就是每次只能一个线程
>
> 再次我们将 js 中运行的代码分为同步代码和异步代码
>
> - 同步代码即是按照代码顺序可以正常执行，没有 ajax 回掉函数
> - 异步代码则是有回调，或者有延时的代码
> - js 的运行机制是先运行同步代码，遇到异步代码时，会将其注册，并放入执行栈中，将其加入消息队列，按照先进先出的原则，当一个函数中同步代码运行完毕后，js 会从消息队列中取出一个消息，执行事件循环，所谓的事件循环就是将异步代码分为宏任务和微任务，首先会去执行微任务，当所有的微任务执行完毕后，会再去寻找新的宏任务，进行执行，执行完毕，再去执行这一上下文中的微任务，如此循环
> - 常见的宏任务有 setimeout setindver
> - 常见的微任务有 promise procsss.nextick

参考文章 https://juejin.cn/post/6844903638238756878#heading-8

#### js 的 setimout 为何时间不准确

> 了解了上面的 js 事件循环机制，其实这个问题就会迎刃而解，对于 js 异步代码，分为宏任务和微任务，由于 setimout 属于宏任务，因此在执行前当存在于很多微任务时候，时间就会不准确

#### js 中 null 和 underfined 的区别

> 简而言之，这是一个历史遗留问题，null 和 uniderfinde 都可以表示不存在的值，只是 null 表示丢失的对象，underdined 声明了，但是未赋值时
>
> 检测类型中 typeof null 为对象 typeof underdinded 为 underfinde

### js 中的 forEach 和 map 的区别

> 两个都会遍历原数组，对数组中的每个值进行操作
>
> - forEach 如果对原数组进行操作，数组的值为基本数据类型时，需要写入第一个参数进行映射

```js
//基本数据类型
let arr = [1, 2, 3, 4, 5];
arr.forEach((item, index, arrTemp) => {
  arrTemp[index] = item * 2;
});
console.log(arr); // [2, 4, 6, 8, 10]

//引用数据类型
let arr = [{ a: 1 }, { a: 10 }, { a: 5 }];
arr.forEach((item, index) => {
  item.a = item.a * 10;
});
console.log(arr); //0: {a: 10} 1: {a: 100}2: {a: 50}
```

- map 会返回一个新的数组，操作时需要返回被操作的值

- ```js
  let arr = [{ a: 1 }, { a: 10 }, { a: 5 }];
  let newArr = arr.map((item) => item.a * 2);
  console.log(newArr); //[2, 20, 10]
  ```

#### 面向对象和面向过程编程的区别

> 两种都是针对编程思想而言 -面向对象：

> - 面向对象会将生活中具体的事情抽象为一个对象，针对这个对象设置属性和方法，同时创建类，可扩散，可继承，弊端就在于使用过程中需要实例化对象，会有一定的性能消耗 -面向过程：

- 面向过程更注重的是问题的解决，复用性较，优点是单一化，性能较高

#### js 如何开启多线程

> h5 中有一个 api。webworker，此 api 可以开启一个后台进程，在 js 主线程运行的同时进行运行，从而达到多线程
>
> webworker 的特点是子线程运行不会阻塞主线程的运行，两者主要是通过 message 发送消息
>
> 子线程完成后，通过 postmessage 向主线程发送消息，主线程通过 message 事件接受消息，即可完成多线程渲染
>
> 主要用法 MDN 详解

#### 前端基础>客户端>浏览器

#### 从 URL 到页面展示经历的过程

##### 要回答这个面试必考问题，我们首先需要了解我们的页面所展示的内容究竟是如何存储在网络世界中的，只有这样，我们才能全面的回答这个问题

> ##### 平时我们所能看到的网页上的任何东西，都是储存在某一台服务器上，为了便于识别管理和查询，每台服务器都有一个编号，这个编号就是网络世界里的 IP 地址，当我们输入 URL 时，就是为了查询具体的 URL 所对应的服务器 IP 地址。

> - 第一步：当我们输入搜索关键字的时候，浏览器无法通过关键字直接获取到 IP 地址，需要先通过 DNS 去解析我们输入的内容，从而找到文件所在的 ip 地址，这一过程就是 DNS 解析，这一过程就会存在<u>**DNS 缓存**</u>，浏览器会保存我们第一次的搜索内容和对应的 ip，当第二次搜索同样的内容时，就不会直接去服务器获取 ip，会通过 DNS 缓存拿起 IP 地址，具体是第一次拿到 IP 地址后，存储在硬盘缓存中，第三次再次刷新请求时，便直接会从内存中拿取对应的 IP 地址
> - 第二步：第一步拿到 ip 地址后，浏览器会和服务器发起会话请求，当我们需要的内容有 CDN 分发时，首次请求会通过 CDN 服务器向主服务器发起请求，获取数据，第二次时，浏览器会通过 CDN 服务器缓存的数据拿取，这一过程就是**<u>CDN 缓存</u>**
> - 第三步：第二步拿到资源后，浏览器会根据 ip 地址和请求参数，去获取数据，这时如果服务器设置了强缓存，服务器将会在首次加载资源的时候，返回 expire 或者 catch-thre ，两者可以同时设置，这样，浏览器在下次请求资源资源时，会先去查找缓存的内容，当缓存不存在的时候，才会去服务器获取相关资源
>
> 浏览器中 from memory catche 和 from disk cache 的区别
>
> - from memory catche 是指从内存中获取缓存的资源，当页面关闭后，资源也会随之释放
> - from disk cache 是指从磁盘中获取缓存的资源，页面关闭后，资源仍然存在，状态码为 304，即服务器资源没有更新，加载本地资源

## 中级

### 前端工程化

> 掘金好文章 https://juejin.cn/post/6844903794094899208
>
> - 代码格式统一 编写统一的 config 文件，约束代码格式
> - 代码提交约束 通过 husky 等插件，调用 git 中的提交钩子，并且进行检查修复

### 框架

#### vue

##### vue 父子组件渲染顺序

##### vue 的 data 为什么是个函数

> 每一个 vue 都是 Vue 类的实例，当 data 为函数的时候，每个 vue 都在调用函数，相当于私有化数据，如果写成对象类，相当于每个实例话的 vue 都拥有共同的数据

##### vue 的异步数据请求放在那个生命周期，理由是什么？

> ssr 不支持挂载，同时在 created 中 data 已经创建，因此可以在这个生命周期中请求数据进行赋值

##### v-for 和 v-if 为什么不建议一起使用

> 当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中
>
> 所以，不推荐 v-if 和 v-for 同时使用
>
> 实际开发中，可以将 v-if 放在外层判断，内层使用 v-for

#### react

##### react 的样式怎么做

> react 官方暂时不支持如同 vue 一样的快级 css
>
> 不过可以使用 css-module，webpack 默认开启 css-module，也可以针对 webpack 进行命名设置，同时 css-module 也支持 compase 的继承等
>
> 因此对于 react 的项目做法可以将全局样式使用 css，对于组件样式可以使用 less，同时配置 calssName 可以做类名等的切换
>
> ![image-20210714145557219](D:\Users\zhangqi\AppData\Roaming\Typora\typora-user-images\image-20210714145557219.png)

##### react 怎么做路由权限

- vue 与 react 路由权限的原理都是前端定义的路由数组中添加权限字段，与后端返回的路由数据进行匹配过滤，有过滤到的则进行显示，没有的定位到无权限页面

##### react 父子组件渲染顺序

> react 父子组件执行顺序遵守，父组件包裹子组件原则，父组件完成 constrtor 数据初始化后， 父组件准备挂载，走渲染函数，同时检测到有子组件，子组件开始初始化数据，预挂载，走渲染函数，挂载，再到父组件挂载

1. Parent constructor
2. Parent componentWillMount
3. Parent render
4. Child constructor
5. Child componentWillMount
6. Child render
7. Child componentDidMount
8. Parent componentDidMount

##### react 事件合成

- react 的本质是一个 ui 渲染框架，react 为了能够兼容所有的浏览器事件处理，自己内部定义了合成事件，我们所写的 react 事件，会被 react 解析为具体的合成事件类型，再去映射到具体的事件中，v17 版本前，react 的合成事件挂在 document 上，v17 后，挂载在顶部容器上，同一个容器，可以容纳多个合成事件，这样为微前端做了铺垫

#### [TS](./前端学点啥-TS疑难点总结.md)

### 性能优化

### 前端性能优化

> - 性能优化主要可从两个方面出发下手，资源加载的体积和网络请求相关资源的速度
> - 性能分析 webpack-bundle-analyzer ，此插件可分析加载的第三方资源所占的比例
> - 资源体积：
>
>   - ngix 反向代理中设置 gzip 代码压缩
>   - 图片体积 静态图片资源进行压缩，网站https://tinyjpg.com/
>   - treeShaking 未使用代码抖落优化，webpack4 中默认支持代码摇树优化
>
> - 加载速度
>   - 组件懒加载 对于未使用的组件，懒加载，提交首屏速度
>   - 缓存 对于静态资源进行缓存，提高服务器响应时间
>   - 雪碧图 减少图片请求次数
>   - 代码分割 将较大的第三方模块进行分割下载，提高加载速度
>   - 多线程打包 webpack 内置的 happyPack

https://juejin.cn/post/6904517485349830670

https://juejin.cn/post/6844904071736852487#heading-20 webpack 打包性能优化

### 工作原理

### 海量数据渲染优化

> 具体实现思路。
>
> - 通过 useRef 获取元素，缓存变量。
> - useEffect 初始化计算容器的高度。截取初始化列表长度。这里需要 div 占位，撑起滚动条。
> - 通过监听滚动容器的 onScroll 事件，根据 scrollTop 来计算渲染区域向上偏移量, 这里需要注意的是，当用户向下滑动的时候，为了渲染区域，能在可视区域内，可视区域要向上滚动；当用户向上滑动的时候，可视区域要向下滚动。
> - 通过重新计算 end 和 start 来重新渲染列表。

```js
function VirtualList() {
  const [dataList, setDataList] = React.useState([]); /* 保存数据源 */
  const [position, setPosition] = React.useState([
    0, 0,
  ]); /* 截取缓冲区 + 视图区索引 */
  const scroll = React.useRef(null); /* 获取scroll元素 */
  const box = React.useRef(null); /* 获取元素用于容器高度 */
  const context = React.useRef(null); /* 用于移动视图区域，形成滑动效果。 */
  const scrollInfo = React.useRef({
    height: 500 /* 容器高度 */,
    bufferCount: 8 /* 缓冲区个数 */,
    itemHeight: 60 /* 每一个item高度 */,
    renderCount: 0 /* 渲染区个数 */,
  });
  React.useEffect(() => {
    const height = box.current.offsetHeight;
    const { itemHeight, bufferCount } = scrollInfo.current;
    const renderCount = Math.ceil(height / itemHeight) + bufferCount;
    scrollInfo.current = { renderCount, height, bufferCount, itemHeight };
    const dataList = new Array(10000).fill(1).map((item, index) => index + 1);
    setDataList(dataList);
    setPosition([0, renderCount]);
  }, []);
  const handleScroll = () => {
    const { scrollTop } = scroll.current;
    const { itemHeight, renderCount } = scrollInfo.current;
    const currentOffset = scrollTop - (scrollTop % itemHeight);
    const start = Math.floor(scrollTop / itemHeight);
    context.current.style.transform = `translate3d(0, ${currentOffset}px, 0)`; /* 偏移，造成下滑效果 */
    const end = Math.floor(scrollTop / itemHeight + renderCount + 1);
    if (end !== position[1] || start !== position[0]) {
      /* 如果render内容发生改变，那么截取  */
      setPosition([start, end]);
    }
  };
  const { itemHeight, height } = scrollInfo.current;
  const [start, end] = position;
  const renderList = dataList.slice(start, end); /* 渲染区间 */
  console.log("渲染区间", position);
  return (
    <div className="list_box" ref={box}>
      <div
        className="scroll_box"
        style={{ height: height + "px" }}
        onScroll={handleScroll}
        ref={scroll}
      >
        <div
          className="scroll_hold"
          style={{ height: `${dataList.length * itemHeight}px` }}
        />
        <div className="context" ref={context}>
          {renderList.map((item, index) => (
            <div className="list" key={index}>
              {" "}
              {item + ""} Item{" "}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
```

### 图片的懒加载

> 当网站有大量的图片需要加载时，如果一次请求所有的图片资源，将会造成白屏和资源浪费，我们可以懒加载图片，
>
> 实现方式就是采用自定义的图片 src，当滚动内底部时，将自定义的图片资源给到真实的图片 src 中
>
> 实际项目中可以引入第三方包https://www.npmjs.com/package/load-js，来解决这一问题，放心用吧，大大大厂都在用的！

### 如何渲染上万个 dom 不卡顿

> 思路主要是分批次进行渲染，因此有两种解决方案
>
> - 第一种，可以设置 settimeot，但是 setimeout 有个问题就是渲染时间不精准，因为 js 单线程的问题，产生的消息队列中的事件循环原因，这就会造成卡顿和掉渣 zheng 现象
> - 第二种，h5 有一个新的 api，requestanimationframework，这是一个可以根据用户屏幕分辨率，自动调整渲染速度的动画，使用方法也很简单，直接调用 widow.requestanimationframework（回调函数） ，回调函数中可以为需要渲染的 dom 事件

### 前端跨域处理 ngix

> ngix 为目前处理跨域问题的主要解决方案，通过 ngix 不仅可以将多个请求资源进行反向代理，还可以通过配置实负载源均衡等
>
> - 反向代理，指的是通过指定的中间域名和端口，去请求服务器的资源，再通过指定的域名和端口返回我们的请求结果
> - 负载均衡指的是，当我们的资源分配在不同的服务器集群时，当用户进行访问的时候，ngix 会去自动判断压力最小的服务器，从而选择该服务器作为我们的资源请求服务器
>
> ```nginx
> // 修改nginx.conf
> worker_processes 1;   //进程设置
> events {
>     worker_connections 1024;    //最大连接数
> }
> http {
>     upstream firstdemo {
>         server 39.106.145.33;
>         server 47.93.6.93;
>     }    //负载均衡集群设置
>     server {
>     listen       80;  //监听的端口
>     server_name  localhost ;
>     auth_basic off;
>     location / {
>         proxy_pass    http://firstdemo;;    //代理地址
>         proxy_set_header Host $host;
>         proxy_connect_timeout 60;   //连接超时
>         proxy_read_timeout 600;   //读取超时
>         proxy_send_timeout 600;  //发送超时
>     }
> }
> }
>
> ```

### 你的代码在那些浏览器上测试过，怎么测的，如何解决兼容问题

> 首先需要明确的是，浏览器兼容问题是必定存在的，把各个浏览器看成妃子，把用户看成皇帝，都想争个宠，总想整点不一样的让皇帝老儿开心，哈哈哈哈哈
>
> 言归正传，由于前端主要跟 html css js 三不类打交道，因此浏览器的兼容问题也关乎三者，如何解决呢？
>
> - css
>
>   - 当我们写的 html 不做任何样式时，浏览器就会加载它自定义的默认样式，然鹅，每家认为的默认样式又不一样，为了让用户使用时=统一起来，于是乎就有了样式大佬写的统一样式，国际通用 normal.css 国内使用淘宝的 reset.css ，目前我的项目里都用过，开锅即用！
>
>   - 别急，除过初始化，css 样式兼容性问题大着呢，如果你认为这就结束了，那你太年轻了！！！，浏览器对于一些特定的 css 样式写法，有所不同理解，这就造成了需要给某些特定的样式写法整点特殊标记，好让浏览器知道使用这种写法我就能认识它，所谓的特殊标记，业界解决方案就是根据每个浏览器的内核，在特定写法前加浏览器内核，从而实现特定标记
>
>   - 具体实现方式有两种
>
>     - 下插件（永远是王道！）
>
>       使用 VScode 的伙伴们，可以直接下载 postcss 插件，这家伙直接可以判定你写的 css 有没有兼容性，如果有，它会自动给你加上浏览器兼容前缀，灰常听话！！
>
>     - webpack 打包配置
>
>       第二种解决方案就是写代码的时候管他兼容性呢，正式上线的时候，在 webpack 中配置 postcss，postcss 是一个关于 css 的平台，内置了一个插件 autoprefix，这个插件可以在打包编译的时候为特定的浏览器 cs 添加前缀，原理也是跟上面一样，配置前缀，具体实现方式看这篇掘金文章喽
>
>       https://juejin.cn/post/6844904017802297352
>
> - js
>
>   - js 中对于很多写法，特定的浏览器不支持，不过现代化的打包工具 webpack 处理好了这一切，babel 不仅可以将 es6+的代码编译为 es5，而且，还内置了 polifill，对于不支持的写法进行了模拟补充

### web-worker sevice-worker

> js 是一门单线程编译语言，也就是说当主线程做事的时候，不可以去做其他的事，web-work 这一 api 的目前可以让 js 在主线程编译的同时，开启后台进程，当后台进程执行完毕当前事件后，通过发送特定消息（post-message）的方式，通知主线程，以便主线程来处理此事

### 如何解决 web 开发中的会话追踪

> 概念理解：所谓的会话追踪就是，每次浏览器发送请求到服务器获取数据的时候，服务器总是需要判断来拿数据的这位靓仔是哪一个，总不能把张三需要的老婆娘家数据给李四需要的爱妃数据吧，这不就乱套了吗，针对这个尴尬的现状，目前业界解决方案就是 cookie session 以及 token 验证，其他三种方式都有缺陷，不推荐
>
> - 第一种 token 验证（基本所有项目都在用）
>   - 实现方式：当用户登录后，后端老哥会返给你一个由字母和数字组成的字符串，没错，这玩意就是 token，原理就是，除过登录注册等页面，其他所有页面，每次发送请求的时候，后端老哥接口先验证一波 token，做法就是把登录拿到的 token 放到本地存储，或者仓库保存起来，在请求拦截中请求头上戴上 token，这样从服务器拿数据时，服务器从头部远远一望，就晓得是那位靓仔，服务器就会给这位靓仔需要的数据
> - 第二种 cookie 和 session 验证
>   - 很多人还不晓得 cookin 和 session 是啥子，建议先去 MDN 了解一波
>   - 当浏览器第一次向服务器发起一个请求的时候，服务器会把一些关键数据保存下来，并生成一个 sessio，其中就有一个 sessionID，服务器返回这条请求数据的时候，也会把这个 sessionID 一并给浏览器，浏览器存到 cookin 中，当第二次浏览器请求的时候，请求头中就会戴上 cooik，好让服务器识别是哪位靓仔
>   - 然鹅，这种方法有一个弊端就是，总有一些用户，担心自己的隐私数据会被泄露，一波操作，直接禁用 cookie，哦豁，这种方法就夭折了
> - 第三种隐藏表单域
>   - 简单说，就是讲表单隐藏起来，用户看不见，但是却绑定了某些值，在提交的时候可以发送给后端，这样子服务器就可以识别是哪个靓仔，真的是骚！！！，不过这种方式的弊端就在于，当用户查找 html 节点时，依然可以发现隐藏的节点，因此这种骚操作不推荐！

### 前端如何做加密

> 前端为何要做加密，最终原因还是不安全
>
> 我们都知道 http 和 https 的区别在于，https 会将浏览器传输给后台的内容进行加密解密处理，但是对于 http，我们的内容并未做加密处理，一旦浏览器发送给后端的敏感内容被抓包，很有可能造成数据泄露等风险，为此在诸如注册登录等需要前端做加密处理
>
> 目前业界可用的加密处理方法很多，介绍一种相对简单，但加密层次较高的方法
>
> MD5，MD5 是一种单向散列算法，也就是只可以加密，不可以解密，使用 MD5 暴露的方法，传入一个常量，会生成一个固定位数的编码值，此编码值唯一，不会更改，常量只要变化一点，编码值会大不一样
>
> 实际项目中，只需要引入 MD5，并对用户的敏感数据进行加密，传给后台，第二次进行使用时，依然使用加密后的编码值校验即可
>
> 你以为这就完了
>
> 未完待续。。。。。
>
> 虽然 MD5 算法原则上不可解密，但目前已有非常多的在线网站，对于简单的密码完全可以通过穷举法和字典法轻易查到对应的 MD5 值
>
> 因此为了增加加密难度，我们需要在使用 MD5 时进行加盐 salt
>
> salt 是密码学中的一个改变，简单讲，当我们吃米饭的时候，加入盐，再进行搅拌，将很难将米饭和盐完全分离，salt 在密码学中就是指设定一个变量或者常量，插入到一个算法结果中，这样得到的混淆结果将会增加密码难度
>
> 实际项目中可以将密码加密后，插入用户名，再次将两者结果进行加密
>
> Md5(md5(密码值)+用户名)

### 前端攻击类型，如何防止攻击

> 前端攻击主要分为两种 CSRF 和 XSS
>
> - CSRF 简单说就是攻击者拿着你的账号信息，向服务器获取数据，然鹅服务器还没办法去识别这个恶人。此类型的攻击从两个角度去降低攻击度，1:增加向后端请求的复杂度。2:增加对用户的信息校验
>   - 涉及登录注册等接口，使用 post，而不是 get 请求
>   - 响应数据中设置 response.setHeader( "Set-Cookie", "cookiename=cookievalue;HttpOnly”);,cookie 只能通过请求去获取，不允许通过 js 脚本等获取 cookie 信息
>   - 设置 token 验证，用户登录后获取一个 session 中的 id 作为 token，请求接口中请求头携带 token
